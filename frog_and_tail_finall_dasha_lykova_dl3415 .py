# -*- coding: utf-8 -*-
"""Frog_and_tail_FINALL_Dasha_Lykova_dl3415.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z3OeciJ95r8nOCgwL67EFv2DzRQpmCMI

# How can frog grow its tail back?

## Data accession

Load data from the link directly or load it through Courseworks .zip file.
"""

!wget https://ftp.ebi.ac.uk/biostudies/fire/E-MTAB-/716/E-MTAB-7716/Files/arrayExpressUpload.zip -O /content/frogtail.zip

#note: I often reimported things because i noticed google colab sometimes doesnt see the
#imports (session ends so imports disappear and I didn't want to rerun the code from the top again )

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

import zipfile
import os

zip_file = "/content/drive/MyDrive/DataScienceMiniProject1/arrayExpressUpload.zip" # replace path to your zip file's path
extract_dir = "/content/drive/MyDrive/DataScienceMiniProject1/Frogtail_files/" # where zip file is going to be extracted to

os.makedirs(extract_dir, exist_ok=True) # create the extraction directory if it doesn't exist

with zipfile.ZipFile(zip_file, 'r') as zip_ref: # unzip
    zip_ref.extractall(extract_dir)

print(f"Files extracted to {extract_dir}")

zip_file = extract_dir+"ArrayExpressV2.zip" # file is a nested zip, dezip again

with zipfile.ZipFile(zip_file, 'r') as zip_ref: # unzip
    zip_ref.extractall(extract_dir)

print(f"Files extracted to {extract_dir}")

"""## Make an anndata matrix using scanpy or anndata

Usually single cell data is either directly stored in highdimensional files with .h5 extensions or in compressed count matrices with several tsv/csv/json logging the covariates information. Here is an example of how to compress and download this data into an anndata object that facilitates downstream single cell analysis.

- AnnData object for single cell data:  [Documentation](https://https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html)
- Scanpy for single cell analysis: [Documentation](https://scanpy.readthedocs.io/en/stable/index.html)

![Capture d’écran 2024-08-28 à 13.26.33.png](data:image/png;base64,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QIAAgaoICHSr0mnzJECgVwIC3V5Juw8BAu0ICHTbUXIOAQIECBAgQIAAgQIJCHQL1CylEiBQCAGBbiHapEgClREQ6Fam1SZKgAABAgQIECBQFQGBblU6bZ4ECPRKQKDbK2n3IUCgHQGBbjtKziFAgAABAgQIECBQIAGBboGapVQCBAohINAtRJsUSaAyAgLdyrTaRAkQIECAAAECBKoiINCtSqfNkwCBXgkIdHsl7T4ECLQjINBtR8k5BAgQIECAAAECBAokINAtULOUSoBAIQQEuoVokyIJVEZAoFuZVpsoAQIECBAgQIBAVQQEulXptHkSINArAYFur6TdhwCBdgQEuu0oOYcAAQIECBAgQIBAgQQaA939lp4aJs+cU6DqlUqAAIH8Cay44cqwq29rrbBLLrkknHvuufkrUkUECFRGQKBbmVabKAECBAgQIECAQFUEGgPdqszZPAkQINArAYFur6TdhwCB4QQEusPJ2E+AAAECBAgQIECgoAIC3YI2TtkECBRCQKBbiDYpkkCpBQS6pW6vyREgQIAAAQIECFRR4O1vf3vo6+ur4tTNmQABAl0XeNGLXhROOumkrt/HDQgQIDCcgEB3OBn7CRAgQIAAAQIECBAgQIAAAQIECBAgkDMBgW7OGqIcAgQIECBAgAABAgQIECBAgAABAgQIDCcg0B1Oxn4CBAgQIECAAAECBAgQIECAAAECBAjkTECgm7OGKIcAAQIECBAgQIAAAQIECBAgQIAAAQLDCQh0h5OxnwABAgQIECBAgAABAgQIECBAgAABAjkTEOjmrCHKIUCAAAECBAgQIECAAAECBAgQIECAwHACAt3hZOwnQIAAAQIECBAgQIAAAQIECBAgQIBAzgQEujlriHIIECBAgAABAgQIECBAgAABAgQIECAwnIBAdzgZ+wkQIECAAAECBAgQIECAAAECBAgQIJAzAYFuzhqiHAIECBAgQIAAAQIECBAgQIAAAQIECAwnINAdTsZ+AgQIECBAgAABAgQIECBAgAABAgQI5ExAoJuzhiiHAAECBAgQIECAAAECBAgQIECAAAECwwkIdIeTsZ9AjgU23PWxsPn+b9UqnDBlXljwsItCGDcpxxUrjQABAgQIECBAgAABAgQIECBAIA0BgW4aisYg0GOBxkB38txjw7zjPtzjCtyOAAECBAgQIECAAAECBAgQ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rAcBawsQ6Fq7fszeIgIff/yx3H///brO9sEHH5T33ntP1zGtONjmzZvl+eefD/ufpN90002iQvRI3rV75swZeeutt9wPuDp79mymudUdxupBWY8++qjkzZs30/2kd6EKndW2H2PHjpWTJ0+md2q636k7ogcNGiTPPfdcuufxZWCBGjVqyPbt2wOfEIFv9u7dK+XKlYtAz3SJgP0FCHTtX2NWiAAC1hQg0LVm3Zg1AnYVINC1a2VZl6kEPvjgA933s1V3BH/yySemcjDTZC5cuCADBgxw3+mq5bzUVgxqC4SSJUtq2a37LtcHHnhAVFCq1aHCUvWwrM6dO2vVpbuf2bNnu+9a9mxVoUXn1atXF/XfoxYtWmjRnaP6qFy5suzZs0fXNas73qtVq6brmAyGgF0ECHTtUknWgQACdhMg0LVbRVkPAtYWINC1dv2YvUUE3nzzTXnyySd1ne19990nEyZM0HVMqwx2+PBhueWWW+T333+PyJSLFi0q33//vTRo0CDs/q9du+beC/mVV14Ju69AHYwaNUpGjBgR6OuQ2tXezVr1lXbgLFmyyMiRI91366r3HMEJGBHorlu3TurWrRvcBDkLAQS8BAh0vTj4gAACCJhGwIhANzH5mqzYd0KOn7ssXa9nOyvT/BiYCAImECDQNUERmIL9BV577TV55plndF0oWy74596yZYuo/VnVA88ifcyaNUs6deoU1jDq7tlvv/02rD6CuVjtBazuLA7nUHveqr19I32oMH7u3LmRHsY2/VetWlV27dql63rU3s567iut6+IYDIEICxDoRhiY7hFAAIFMCugZ6O44niA//3FYlu48JucuXZV65YvI6NvqZHLmXIYAAnYUINC1Y1VZk+kE1B6t6s5CPY/HHnvMvd+qnmOafayjR4+675o9dOiQLlONiopy3wVcvnz5TI2nHrb26aefZurazFyk7q79z3/+k5lLZfjw4fLf//43U9dm5qKuXbuGve9xZsa14jVG7KH7yy+/SOvWra3IxZwRMFyAQNfwEjABBBBAwK9ApAPdUxevukLcI7LQFeQeivfeZo1A129JaETA0QIEuo4uP4vXS2Do0KHy6quv6jWce5yBAweK2uqB4y+Bixcvuu8YVA9B0/OoU6eOrFy5UnLmzBnSsOphYuoha3oeahuDxYsXi3rAWyjHjBkzpEePHqFcosm5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)
"""

# Commented out IPython magic to ensure Python compatibility.
# pin packages to versions that don't cause incompatibility that breaks the code
# %pip install "scanpy==1.10.2" "anndata==0.12.2" scikit-misc numpy scipy scikit-learn umap-learn matplotlib seaborn

# Commented out IPython magic to ensure Python compatibility.
#pin packages to versions that don't cause incompatibility that breaks the code
# %pip install torch --index-url https://download.pytorch.org/whl/cpu

# Commented out IPython magic to ensure Python compatibility.
 #clustering
# %pip install igraph leidenalg louvain

# Commented out IPython magic to ensure Python compatibility.
# denoising
# %pip install magic-impute

# Commented out IPython magic to ensure Python compatibility.
# batch integration
# %pip install harmonypy bbknn

# remove the broken leftover that causes the "Ignoring invalid distribution ~andas" spam error
!rm -rf /usr/local/lib/python3.12/dist-packages/~andas

# Commented out IPython magic to ensure Python compatibility.
#install compatible versions of package
# %pip install  --only-binary=:all: pandas==2.2.2

# Commented out IPython magic to ensure Python compatibility.
# %pip install arviz==0.17.0

# Commented out IPython magic to ensure Python compatibility.
# %pip install "scvi-tools==1.1.2"

# Commented out IPython magic to ensure Python compatibility.
# %pip install scanpy

# path to project folder
extract_dir = "/content/drive/MyDrive/DataScienceMiniProject1/Frogtail_files/"

#imports
import scanpy as sc
import anndata as ad
import pandas as pd
import numpy as np
from scipy.io import mmread
from scipy import sparse

#extract variables
X = mmread(extract_dir + 'ArrayExpress/countsMatrix.mtx')
genes = pd.read_csv(extract_dir + 'ArrayExpress/genes.csv', sep=' ', header=None)
cells = pd.read_csv(extract_dir + 'ArrayExpress/cells.csv', sep=' ', header=None)
labels = pd.read_csv(extract_dir + 'ArrayExpress/labels.csv')
meta = pd.read_csv(extract_dir + 'ArrayExpress/meta.csv')

# make X csr
X = X.tocsr()
#transpose
adata = ad.AnnData(X.T)

cells.columns = ['barcode_cells']
meta_aug = pd.merge(meta, labels, left_on='sample', right_on='Sample', how='left')

adata.var_names = genes[0]
adata.obs = pd.merge(cells, meta_aug, left_on='barcode_cells', right_on='cell')

adata

adata.var

adata.X = adata.X.tocsr()

adata.write_h5ad(extract_dir+'cleaned_processed_frogtail.h5ad') #create the cleaned and processed data file

!pip list

"""## Load data"""

extract_dir = "/content/drive/MyDrive/DataScienceMiniProject1/Frogtail_files/CleanedData/"
adata = ad.read_h5ad("/content/drive/MyDrive/DataScienceMiniProject1/Frogtail_files/CleanedData/cleaned_processed_frogtail.h5ad") # ad.read_h5ad()
adata.X = adata.X.tocsr() #convert to CSR format for faster cell operations and Scanpy compatibility

adata.X.todense() #this is purely to print out the data (coded by prof).

adata.obs

adata.X

adata

"""## Processing data"""

adata.layers["counts"] = adata.X.copy() # save raw counts

sc.pp.normalize_total(adata)

# logarithmize the data
sc.pp.log1p(adata)

#filter out genes with too little cells and cells with too little genes
sc.pp.filter_genes(adata, min_cells=3)
sc.pp.filter_cells(adata, min_genes=200)
sc.pp.highly_variable_genes(adata, n_top_genes=2300)

sc.pl.highly_variable_genes(adata)

from scipy.sparse import csr_matrix, issparse
from sklearn.metrics import silhouette_score, adjusted_rand_score, normalized_mutual_info_score
import os


#paths, folders, data
BASE_DIR = "/content/drive/MyDrive/DataScienceMiniProject1" #root directory of the project
FIG_DIR  = f"{BASE_DIR}/figures"
OUT_DIR  = f"{BASE_DIR}/outputs"
REFS_DIR = f"{BASE_DIR}/refs"

#ensure the folders exist on a disk
os.makedirs(FIG_DIR, exist_ok=True)
os.makedirs(OUT_DIR, exist_ok=True)
os.makedirs(REFS_DIR, exist_ok=True)

#directory for figures
sc.settings.figdir = FIG_DIR

#load cleaned andata
if "adata" not in globals():
    CLEAN_FILE = f"{BASE_DIR}/Frogtail_files/CleanedData/cleaned_processed_frogtail.h5ad"
    adata = sc.read_h5ad(CLEAN_FILE)
    print("Loaded cleaned data")

# sparse CSR format
if not issparse(adata.X):
    adata.X = csr_matrix(adata.X)

# ensure counts layer exists
if "counts" not in adata.layers:
    # check for log1p - if X has small non-integer values, it’s log1p
    max_val = adata.X.max() if not issparse(adata.X) else adata.X.data.max()

    if max_val < 20: # < 20 means small
        print("adata.X appears log-transformed. Reconstructing raw counts in 'counts'")
        counts = adata.X.copy()
        if issparse(counts):
            counts.data = np.expm1(counts.data)
        else:
            counts = np.expm1(counts)
        adata.layers["counts"] = counts
    else:
        print("adata.X appears to be raw counts. Copying to counts'")
        adata.layers["counts"] = adata.X.copy()
else:
    print("'counts' layer already exists")

#summary
#check to confirm if data log or not
print(f"adata.X  (main): log1p={ 'log1p' in adata.uns or adata.X.max()<20 }  range=({adata.X.min():.2f}, {adata.X.max():.2f})")
print(f"counts layer   : exists={ 'counts' in adata.layers }")


BATCH_KEY = "batch"     #for integration
LABEL_KEY = "cluster"   #reference labels from professor for ARI/NMI

# Commented out IPython magic to ensure Python compatibility.
# %pip install --user scikit-misc
import warnings

#restart from base on every run (be bale to rerun code without issues)
if "ADATA_BASE" not in globals():
    ADATA_BASE = adata.copy()   # keep an untouched baseline in memory
    print("Cached ADATA_BASE")
else:
    print("Reusing cached ADATA_BASE")

adata = ADATA_BASE.copy()

#ensure raw counts layer. if not, best-effort fallback from X (may be log)
if "counts" not in adata.layers:
    warnings.warn("No `adata.layers['counts']` found. Creating a fallback from adata.X")
    Xdense = adata.X.A if sparse.issparse(adata.X) else adata.X
    adata.layers["counts"] = np.expm1(Xdense)

# shape & sparsity summary (of current X and raw counts)
n_cells, n_genes = adata.shape
nnz_X = adata.X.nnz if hasattr(adata.X, "nnz") else np.count_nonzero(adata.X)
C = adata.layers["counts"]
nnz_C = C.nnz if hasattr(C, "nnz") else np.count_nonzero(C)

print(f"[X]   Cells: {n_cells:,}  Genes: {n_genes:,}  Nonzeros: {nnz_X:,}  Sparsity: {nnz_X/(n_cells*n_genes):.3%}")
print(f"[raw] Nonzeros: {nnz_C:,}  Sparsity: {nnz_C/(n_cells*n_genes):.3%}")

#Hghly variable genes
sc.pp.highly_variable_genes(
    adata,
    layer="counts",     # use raw counts layer
    flavor="seurat_v3",
    n_top_genes=3000,
)
print("HVGs selected:", int(adata.var["highly_variable"].sum()))
adata = adata[:, adata.var["highly_variable"]].copy()

# scale without zero centering
sc.pp.scale(adata, zero_center=False, max_value=10)

# PCA --> neighbors ---> UMAP
sc.tl.pca(adata, svd_solver="arpack")
sc.pp.neighbors(adata, n_neighbors=15, n_pcs=50)
sc.tl.umap(adata)

#sabity check
print("Post-HVG shape:", adata.shape,
      "||| PCA shape:", adata.obsm["X_pca"].shape,
      "||| UMAP shape:", adata.obsm["X_umap"].shape)

import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import issparse

# make sure adata.layers["counts"] exists first
if "counts" in adata.layers:
    C = adata.layers["counts"]
else:
    from scipy.sparse import issparse
    if issparse(adata.X):
        C = adata.X
    else:
        import numpy as np
        C = np.expm1(adata.X)  # reconstruct if X is log1p

#recompute QC metrics
import numpy as np
adata.obs["n_genes_raw"] = np.asarray((C > 0).sum(axis=1)).ravel()
adata.obs["total_counts_raw"] = np.asarray(C.sum(axis=1)).ravel()

#plot the scatterplot
fig, ax = plt.subplots(figsize=(5,4))
ax.scatter(
    adata.obs["total_counts_raw"],
    adata.obs["n_genes_raw"],
    s=4, alpha=0.3, color="#7B3F99"
)
ax.set_xscale("log")
ax.set_xlabel("Total counts per cell (log scale)")
ax.set_ylabel("Number of genes detected per cell")
ax.set_title("Sequencing Depth vs Transcriptional Complexity Across Cells")
plt.tight_layout()
plt.show()

#The two curved lines of the scatter suggest
#that the dataset contains two broad cell populations
# or technical batches with different capture efficiency or RNA content

#no obvious low-count outlier cloud  so very few dead/low-quality cells

#Cells that have more RNA molecules captured (further to the right)
#also have more genes detected (higher up)
#such upward pattern means the data ws sequenced deeply enough
#to capture real biological signal  (ie cells with more reads show richer
#gene expression) - so we have a good single cell dataset

# baseline clustering (Leiden + Louvain) + UMAP + Metrics
import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import silhouette_score, adjusted_rand_score, normalized_mutual_info_score

# compute leiden and louvain clusterings
sc.tl.leiden(adata, key_added="leiden", resolution=1.0)
sc.tl.louvain(adata, key_added="louvain", resolution=1.0)

# helper functions for metrics
def silhouette_pca(a, label_key):
    return silhouette_score(a.obsm["X_pca"], a.obs[label_key].astype(str))

def ari_nmi_vs_ref(a, label_key, ref_key):
    if ref_key in a.obs.columns:
        y_true = a.obs[ref_key].astype(str)
        y_pred = a.obs[label_key].astype(str)
        ari = adjusted_rand_score(y_true, y_pred)
        nmi = normalized_mutual_info_score(y_true, y_pred)
        return ari, nmi
    return np.nan, np.nan

# compute metrics
sil_leiden  = silhouette_pca(adata, "leiden")
sil_louvain = silhouette_pca(adata, "louvain")

LABEL_KEY = "cluster"
ari_leiden,  nmi_leiden  = ari_nmi_vs_ref(adata, "leiden",  LABEL_KEY)
ari_louvain, nmi_louvain = ari_nmi_vs_ref(adata, "louvain", LABEL_KEY)

metrics_baseline = pd.DataFrame([{
    "variant": "baseline",
    "sil_leiden": sil_leiden,
    "sil_louvain": sil_louvain,
    "ari_leiden": ari_leiden,
    "nmi_leiden": nmi_leiden,
    "ari_louvain": ari_louvain,
    "nmi_louvain": nmi_louvain
}])

# save metrics
OUT_DIR = "/content/drive/MyDrive/DataScienceMiniProject1/outputs"
os.makedirs(OUT_DIR, exist_ok=True)
metrics_path = os.path.join(OUT_DIR, "metrics_baseline.csv")
metrics_baseline.to_csv(metrics_path, index=False)

print("Baseline clustering metrics:")
print(metrics_baseline)
print("\nSaved baseline metrics to:", metrics_path)

# use pastel palette for the plots
pastel_palette = sns.color_palette("pastel", n_colors=20).as_hex()

# show UMAPs for leiden and louvain clusters with pastel colors
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

sc.pl.umap(
    adata,
    color="leiden",
    palette=pastel_palette,
    legend_loc="on data",
    title="UMAP (Leiden Clusters)",
    ax=axes[0],
    frameon=False,
    show=False
)

sc.pl.umap(
    adata,
    color="louvain",
    palette=pastel_palette,
    legend_loc="on data",
    title="UMAP (Louvain Clusters)",
    ax=axes[1],
    frameon=False,
    show=False
)

plt.tight_layout()
plt.savefig(os.path.join(OUT_DIR, "umap_leiden_louvain_pastel.png"), dpi=150)
plt.show()

from sklearn.metrics import silhouette_score, adjusted_rand_score, normalized_mutual_info_score

# compute silhouette scores
sil_leiden  = silhouette_score(adata.obsm["X_pca"], adata.obs["leiden"].astype(str))
sil_louvain = silhouette_score(adata.obsm["X_pca"], adata.obs["louvain"].astype(str))

print(f"silhouette (leiden):  {sil_leiden:.3f}")
print(f"silhouette (louvain): {sil_louvain:.3f}")

# compute ARI/NMI if ground-truth exists
LABEL_KEY = "cluster"  # or change to the correct reference label
if LABEL_KEY in adata.obs.columns:
    y_ref = adata.obs[LABEL_KEY].astype(str)

    ari_leiden  = adjusted_rand_score(y_ref, adata.obs["leiden"].astype(str))
    nmi_leiden  = normalized_mutual_info_score(y_ref, adata.obs["leiden"].astype(str))
    ari_louvain = adjusted_rand_score(y_ref, adata.obs["louvain"].astype(str))
    nmi_louvain = normalized_mutual_info_score(y_ref, adata.obs["louvain"].astype(str))

    print(f"ari (leiden):  {ari_leiden:.3f}")
    print(f"nmi (leiden):  {nmi_leiden:.3f}")
    print(f"ari (louvain): {ari_louvain:.3f}")
    print(f"nmi (louvain): {nmi_louvain:.3f}")
else:
    print("no reference label found — skipping ARI/NMI")

# KMeans clustering and evaluation with inline UMAP plot

import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score, adjusted_rand_score, normalized_mutual_info_score

# helper to compute silhouette score on PCA
def silhouette_pca(a, label_key):
    return silhouette_score(a.obsm["X_pca"], a.obs[label_key].astype(str))

# helper to compute ARI and NMI vs reference labels
def ari_nmi_vs_ref(a, label_key, ref_key):
    if ref_key in a.obs.columns:
        y_true = a.obs[ref_key].astype(str)
        y_pred = a.obs[label_key].astype(str)
        ari = adjusted_rand_score(y_true, y_pred)
        nmi = normalized_mutual_info_score(y_true, y_pred)
        return ari, nmi
    return np.nan, np.nan

OUT_DIR = "/content/drive/MyDrive/DataScienceMiniProject1/outputs"
os.makedirs(OUT_DIR, exist_ok=True)

LABEL_KEY = "cluster"

# run KMeans clustering on PCA
print("running kmeans clustering on PCA-reduced data...")
kmeans = KMeans(n_clusters=10, random_state=42)
adata.obs["kmeans"] = kmeans.fit_predict(adata.obsm["X_pca"]).astype(str)

# compute metrics
sil_kmeans = silhouette_pca(adata, "kmeans")
ari_kmeans, nmi_kmeans = ari_nmi_vs_ref(adata, "kmeans", LABEL_KEY)

metrics_kmeans = pd.DataFrame([{
    "variant": "kmeans",
    "silhouette": sil_kmeans,
    "ari": ari_kmeans,
    "nmi": nmi_kmeans
}])

# save metrics
metrics_path = os.path.join(OUT_DIR, "metrics_kmeans.csv")
metrics_kmeans.to_csv(metrics_path, index=False)

print("\nkmeans clustering metrics:")
print(metrics_kmeans)
print("saved metrics to:", metrics_path)

# display UMAP with pastel colors
pastel_palette = sns.color_palette("pastel", n_colors=10).as_hex()
fig, ax = plt.subplots(figsize=(6, 5))

sc.pl.umap(
    adata,
    color="kmeans",
    title="UMAP (KMeans Clusters)",
    legend_loc="on data",
    palette=pastel_palette,
    ax=ax,
    frameon=False,
    show=False
)

plt.tight_layout()
plt.show()

# Commented out IPython magic to ensure Python compatibility.
from IPython.display import Image, display

# paths
BASE_DIR = "/content/drive/MyDrive/DataScienceMiniProject1"
REFS_DIR = f"{BASE_DIR}/refs"
OUT_DIR  = f"{BASE_DIR}/outputs"
FIG_DIR  = f"{BASE_DIR}/figures"
os.makedirs(REFS_DIR, exist_ok=True)
os.makedirs(OUT_DIR,  exist_ok=True)
os.makedirs(FIG_DIR,  exist_ok=True)

# %matplotlib inline
sc.settings.autoshow = False
sc.settings.figdir   = FIG_DIR

# ensure .raw exists
try:
    if getattr(adata, "raw", None) is None:
        adata.raw = ADATA_BASE
except NameError:
    adata.raw = adata.copy()
    print("ADATA_BASE not found; set adata.raw = adata (may be HVG-subset).")

# ensure Leiden exists
if "leiden" not in adata.obs.columns:
    print("Leiden labels not found — computing Leiden at resolution=1.0")
    if "X_pca" not in adata.obsm:
        sc.tl.pca(adata, svd_solver="arpack")
    if "neighbors" not in adata.uns:
        n_pcs = min(50, adata.obsm["X_pca"].shape[1])
        sc.pp.neighbors(adata, n_neighbors=15, n_pcs=n_pcs)
    if "X_umap" not in adata.obsm:
        sc.tl.umap(adata)
    sc.tl.leiden(adata, key_added="leiden", resolution=1.0)

# ensure Louvain exists
if "louvain" not in adata.obs.columns:
    print("Louvain labels not found — computing Louvain at resolution=1.0")
    sc.tl.louvain(adata, key_added="louvain", resolution=1.0)

# ensure KMeans exists
from sklearn.cluster import KMeans
if "kmeans" not in adata.obs.columns:
    print("KMeans not found — computing with n_clusters=10 on PCA space")
    kmeans = KMeans(n_clusters=10, random_state=42)
    adata.obs["kmeans"] = kmeans.fit_predict(adata.obsm["X_pca"]).astype(str)

# marker selection (Wilcoxon / LogReg) — save to .uns with cluster method key
if "wilcox" not in adata.uns:
    print("Wilcoxon markers not found — computing for Leiden")
    sc.tl.rank_genes_groups(adata, groupby="leiden", method="wilcoxon", key_added="wilcox")

if "louvain_wilcox" not in adata.uns:
    print("Wilcoxon markers not found — computing for Louvain")
    sc.tl.rank_genes_groups(adata, groupby="louvain", method="wilcoxon", key_added="louvain_wilcox")

if "kmeans_logreg" not in adata.uns:
    print("LogReg markers not found — computing for KMeans")
    sc.tl.rank_genes_groups(adata, groupby="kmeans", method="logreg", key_added="kmeans_logreg")

# clean gene symbols for matching
def clean_symbol(x: str) -> str:
    s = str(x).upper()
    s = s.split(".")[0].split("_")[0]
    return s

adata.var["symbol_clean"] = [clean_symbol(g) for g in adata.var_names]
if adata.raw is not None:
    adata.raw.var["symbol_clean"] = [clean_symbol(g) for g in adata.raw.var_names]

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patheffects as pe
import scanpy as sc

OTHER_GRAY = "#d3d3d3"
ROC_PASTEL = "#a6cee3"

def render_umap_highlight(adata, method_col, roc_cluster, out_path, title):
    """Render UMAP with ROC cluster pastel-highlighted, no legend, and an on-plot ROC label."""
    cats = list(adata.obs[method_col].cat.categories)
    roc_id = str(roc_cluster)
    palette = [ROC_PASTEL if c == roc_id else OTHER_GRAY for c in cats]

    fig, ax = plt.subplots(1, 1, figsize=(6, 5))
    sc.pl.umap(
        adata,
        color=method_col,
        palette=palette,
        groups=[roc_cluster],
        legend_loc=None,
        frameon=False,
        show=False,
        ax=ax,
        title=title
    )

    mask = (adata.obs[method_col].astype(str).values == roc_id)
    if mask.any():
        xy = adata.obsm["X_umap"][mask, :]
        x, y = float(np.mean(xy[:,0])), float(np.mean(xy[:,1]))
        txt = ax.text(x, y, "ROC", color="black", fontsize=14, weight="bold",
                      ha="center", va="center")
        txt.set_path_effects([pe.withStroke(linewidth=3, foreground="white")])

    fig.tight_layout()
    fig.savefig(out_path, dpi=200)
    plt.show()
    print("Saved:", out_path)

#ROC reference list (copied from supplement table 3)
roc_csv = os.path.join(REFS_DIR, "rocGenes.csv")
if not os.path.exists(roc_csv):
    pd.Series([
        "WNT5A","LOC100488523","LOC100492954","EGFL6","LPAR3","CPA6","SP9","FGF9","FBN2","TINAGL1",
        "FGF7","VWDE","LEF1","LAMB2","FGFR4","RSPO2","CPA6","LOC100498358","KRT","LOC100486832",
        "JAG1","XELAEV18043128M","DLX2","TP73","GDF6","XELAEV18046800M","NID2","IGFBP2","ISM2",
        "LOC100493805","FREM2","XELAEV18044182M","BMP5","TSPEAR","SEMA3F","ROBO4","JCHAIN",
        "ADAMTS18","PLTP","XELAEV18034799M","LAMB1","UNC5B","MMP28","FGF10","PZP","GALNT15"
    ]).to_csv(roc_csv, index=False)
roc_ref = pd.read_csv(roc_csv, header=None).iloc[:,0].astype(str).str.upper().tolist()
roc_ref_set = set(roc_ref)

#overlap per Leiden cluster (top-50 Wilcoxon markers)
wilcox_names = pd.DataFrame(adata.uns["wilcox"]["names"])
def clean_list(lst): return [clean_symbol(x) for x in lst]
overlap = {}
for cl in wilcox_names.columns:
    top50_clean = set(clean_list(wilcox_names[cl][:50]))
    overlap[cl] = len(top50_clean & roc_ref_set)

roc_cluster = max(overlap, key=overlap.get)
pd.Series(overlap, name="roc_overlap_top50_wilcoxon_clean").to_csv(
    os.path.join(OUT_DIR, "roc_overlap_baseline_clean.csv")
)
print(f"ROC cluster (cleaned symbols): {roc_cluster} | overlap(top-50) = {overlap[roc_cluster]}")

#map cleaned symbols to present var names
def map_to_present_symbols(target_list, var_symbols, var_names):
    target = set(target_list); hits = []
    for i, sym in enumerate(var_symbols):
        if sym in target:
            hits.append(var_names[i])
    return hits

panel_raw = []
if adata.raw is not None and "symbol_clean" in adata.raw.var:
    panel_raw = map_to_present_symbols(roc_ref, adata.raw.var["symbol_clean"].tolist(), list(adata.raw.var_names))
panel_cur = map_to_present_symbols(roc_ref, adata.var["symbol_clean"].tolist(), list(adata.var_names))
plot_panel = panel_raw if len(panel_raw) >= len(panel_cur) else panel_cur

#dotplot
if len(plot_panel) == 0:
    print("No ROC genes found after cleaning — expand rocGenes.csv or check symbol mapping.")
else:
    use_raw_flag = (len(panel_raw) >= len(panel_cur)) and (adata.raw is not None)

sc.pl.dotplot(
    adata,
    var_names=plot_panel,
    groupby="leiden",
    dot_max=0.6,
    color_map="plasma",
    dendrogram=True,
    use_raw=use_raw_flag,
    show=False,
    title="Expression of ROC Reference Genes Across Leiden Clusters",
)

fig = plt.gcf()
ax = fig.axes[0]
ax.set_title("Expression of ROC Reference Genes Across Leiden Clusters", fontsize=43, pad=15)
fig.tight_layout()
fig.savefig(os.path.join(FIG_DIR, "dotplot_roc_panel_FIXED.png"), dpi=150)
#plt.show()

# UMAP with ROC cluster highlighted (bright red)
palette = [("#d62728" if c == str(roc_cluster) else "#d3d3d3")
           for c in adata.obs["leiden"].cat.categories]
sc.pl.umap(
    adata,
    color="leiden",
    groups=[roc_cluster],
    palette=palette,
    title=f"UMAP Highlighting ROC Cluster {roc_cluster} for Leiden",
    show=False,
    save="_roc_cluster_FIXED.png"
)
umap_path = os.path.join(FIG_DIR, "umap_roc_cluster_FIXED.png")
print("Saved:", umap_path)
display(Image(filename=umap_path))

from IPython.display import Image, display
import matplotlib.pyplot as plt
import os

#loop over Louvain and KMeans
for method, uns_key in [("louvain", "louvain_wilcox"), ("kmeans", "kmeans_logreg")]:
    marker_names = pd.DataFrame(adata.uns[uns_key]["names"])

    #compute overlap of top 50 markers with ROC list
    def clean_list(lst): return [clean_symbol(x) for x in lst]
    overlap = {}
    for cl in marker_names.columns:
        top50_clean = set(clean_list(marker_names[cl][:50]))
        overlap[cl] = len(top50_clean & roc_ref_set)

    #get ROC-enriched cluster
    roc_cluster = max(overlap, key=overlap.get)
    print(f"\n[{method.upper()}] ROC cluster (cleaned symbols): {roc_cluster} | overlap(top-50) = {overlap[roc_cluster]}")

    #dotplot
    sc.pl.dotplot(
        adata,
        var_names=plot_panel,
        groupby=method,
        dot_max=0.6,
        color_map="plasma",
        dendrogram=True,
        use_raw=use_raw_flag,
        show=False
    )
    fig = plt.gcf()
    ax = fig.axes[0]
    ax.set_title(f"Expression of ROC Reference Genes Across {method.capitalize()} Clusters", fontsize=43, pad=15)
    fig.tight_layout()
    dot_path = os.path.join(FIG_DIR, f"dotplot_roc_panel_{method.upper()}.png")
    fig.savefig(dot_path, dpi=150)
    display(Image(filename=dot_path))

    #umap highlighting roc cluster
    palette = [("#d62728" if c == str(roc_cluster) else "#d3d3d3")
               for c in adata.obs[method].cat.categories]
    sc.pl.umap(
        adata,
        color=method,
        groups=[roc_cluster],
        palette=palette,
        title=f"UMAP Highlighting ROC Cluster {roc_cluster} for {method.capitalize()}",
        show=False,
        save=f"_roc_cluster_{method.upper()}.png"
    )
    umap_path = os.path.join(FIG_DIR, f"umap_roc_cluster_{method.upper()}.png")
    print("Saved:", umap_path)
    display(Image(filename=umap_path))

#combine umap-highlight figures and dot-plot figures into two panels
import os
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

BASE_DIR = "/content/drive/MyDrive/DataScienceMiniProject1"
FIG_DIR  = f"{BASE_DIR}/figures"

#maps to files
umap_candidates = {
    "Leiden":  [
        os.path.join(FIG_DIR, "umap_roc_cluster_FIXED.png"),
        os.path.join(FIG_DIR, "umap_roc_cluster_LEIDEN.png")
    ],
    "Louvain": [os.path.join(FIG_DIR, "umap_roc_cluster_LOUVAIN.png")],
    "KMeans":  [os.path.join(FIG_DIR, "umap_roc_cluster_KMEANS.png")],
}

dot_candidates = {
    "Leiden":  [
        os.path.join(FIG_DIR, "dotplot_roc_panel_FIXED.png"),
        os.path.join(FIG_DIR, "dotplot_roc_panel_LEIDEN.png")
    ],
    "Louvain": [os.path.join(FIG_DIR, "dotplot_roc_panel_LOUVAIN.png")],
    "KMeans":  [os.path.join(FIG_DIR, "dotplot_roc_panel_KMEANS.png")],
}

def first_existing(paths):
    for p in paths:
        if os.path.exists(p):
            return p
    return None

#resolve actual existing paths
umap_files = [(method, first_existing(paths)) for method, paths in umap_candidates.items()]
dot_files  = [(method, first_existing(paths)) for method, paths in dot_candidates.items()]

umap_files = [(m, p) for (m, p) in umap_files if p is not None]
dot_files  = [(m, p) for (m, p) in dot_files  if p is not None]

#helper to make a 1xN image grid with titles (horizontal)
def make_panel_horizontal(pairs, out_path, suptitle):
    if not pairs:
        print(f"no images found for {suptitle}")
        return
    n = len(pairs)
    fig, axes = plt.subplots(1, n, figsize=(5*n, 5))
    if n == 1:
        axes = [axes]
    for ax, (method, path) in zip(axes, pairs):
        img = mpimg.imread(path)
        ax.imshow(img)
        ax.set_title(method, fontsize=18, pad=10)
        ax.axis("off")
    fig.suptitle(suptitle, fontsize=20, y=0.98)
    plt.tight_layout(rect=(0, 0, 1, 0.95))
    fig.savefig(out_path, dpi=150)
    plt.show()
    print("Saved:", out_path)

# helper to make an Nx1 image grid with minimal spacing
def make_panel_vertical(pairs, out_path, suptitle):
    if not pairs:
        print(f"no images found for {suptitle}")
        return
    n = len(pairs)
    fig, axes = plt.subplots(n, 1, figsize=(12, 6*n))
    if n == 1:
        axes = [axes]

    for ax, (method, path) in zip(axes, pairs):
        img = mpimg.imread(path)
        ax.imshow(img)
        ax.set_title(method, fontsize=14, pad=4)
        ax.axis("off")

    # remove all vertical spacing
    plt.subplots_adjust(hspace=0, top=0.96, bottom=0.02)

    #manually align axes edges flush
    for i, ax in enumerate(axes):
        pos = ax.get_position()
        if i > 0:
            prev_pos = axes[i-1].get_position()
            pos.y1 = prev_pos.y0
            pos.y0 = pos.y1 - (prev_pos.height)
            ax.set_position(pos)

    fig.suptitle(suptitle, fontsize=14, y=0.995)
    fig.savefig(out_path, dpi=200, bbox_inches="tight")
    plt.show()
    print("Saved:", out_path)

#combined umap panel
combined_umap_path = os.path.join(FIG_DIR, "combined_umaps_roc.png")
make_panel_horizontal(umap_files, combined_umap_path,
                      "UMAP highlighting ROC cluster (Leiden / Louvain / KMeans)")

#combined dot-plot panel
combined_dot_path  = os.path.join(FIG_DIR, "combined_dotplots_vertical_roc.png")
make_panel_vertical(dot_files, combined_dot_path,
                    "Expression of ROC reference genes across clusters (Leiden / Louvain / KMeans)")

from IPython.display import Image, display
import matplotlib.pyplot as plt
import matplotlib.patheffects as pe
import numpy as np
import pandas as pd
import os
import scanpy as sc

# ensure FIG_DIR exists
if 'FIG_DIR' not in globals():
    BASE_DIR = "/content/drive/MyDrive/DataScienceMiniProject1"
    FIG_DIR  = os.path.join(BASE_DIR, "figures")
os.makedirs(FIG_DIR, exist_ok=True)

# color constants
OTHER_GRAY = "#d3d3d3"
ROC_PASTEL = "#f4a7b9"

def annotate_centroid(ax, adata, method, roc_cluster):
    """Mark the ROC cluster centroid with text."""
    mask = (adata.obs[method].astype(str).values == str(roc_cluster))
    if not mask.any():
        return
    xy = adata.obsm["X_umap"][mask, :]
    x, y = float(np.mean(xy[:, 0])), float(np.mean(xy[:, 1]))
    txt = ax.text(
        x, y, "ROC", color="black", fontsize=12,
        ha="center", va="center"
    )
    txt.set_path_effects([pe.withStroke(linewidth=3, foreground="white")])

# loop over Leiden, Louvain, KMeans with saved figures and larger titles
for method, uns_key in [
    ("leiden",  "wilcox"),
    ("louvain", "louvain_wilcox"),
    ("kmeans",  "kmeans_logreg"),
]:
    # get marker gene names
    marker_names = pd.DataFrame(adata.uns[uns_key]["names"])

    # compute overlap of top 50 markers with ROC list
    def clean_list(lst): return [clean_symbol(x) for x in lst]
    overlap = {}
    for cl in marker_names.columns:
        top50_clean = set(clean_list(marker_names[cl][:50]))
        overlap[cl] = len(top50_clean & roc_ref_set)

    # get ROC-enriched cluster dynamically (no hardcoding)
    roc_cluster = max(overlap, key=overlap.get)
    print(f"\n[{method.upper()}] ROC cluster (cleaned symbols): {roc_cluster} | overlap(top-50) = {overlap[roc_cluster]}")

    # dotplot with large title
    sc.pl.dotplot(
        adata,
        var_names=plot_panel,
        groupby=method,
        dot_max=0.6,
        color_map="plasma",
        dendrogram=True,
        use_raw=use_raw_flag,
        show=False
    )
    fig = plt.gcf()
    ax = fig.axes[0]
    ax.set_title(f"Expression of ROC Reference Genes Across {method.capitalize()} Clusters", fontsize=43, pad=15)
    fig.tight_layout()
    dot_path = os.path.join(FIG_DIR, f"dotplot_roc_panel_{method.upper()}.png")
    fig.savefig(dot_path, dpi=150)
    display(Image(filename=dot_path))

    #UMAP highlighting ROC cluster
    cats = list(adata.obs[method].cat.categories)
    palette = [ROC_PASTEL if c == str(roc_cluster) else OTHER_GRAY for c in cats]

    fig, ax = plt.subplots(1, 1, figsize=(6, 5))
    sc.pl.umap(
        adata,
        color=method,
        palette=palette,
        groups=[roc_cluster],
        legend_loc=None,
        frameon=False,
        show=False,
        ax=ax,
        title=f"UMAP Highlighting ROC Cluster for {method.capitalize()}"
    )
    annotate_centroid(ax, adata, method, roc_cluster)
    fig.tight_layout()
    umap_path = os.path.join(FIG_DIR, f"umap_roc_cluster_{method.upper()}.png")
    fig.savefig(umap_path, dpi=200)
    plt.close(fig)
    print("Saved:", umap_path)
    display(Image(filename=umap_path))

umap_candidates = {
    "Leiden":  [
        os.path.join(FIG_DIR, "umap_roc_cluster_LEIDEN.png")
    ],
    "Louvain": [os.path.join(FIG_DIR, "umap_roc_cluster_LOUVAIN.png")],
    "KMeans":  [os.path.join(FIG_DIR, "umap_roc_cluster_KMEANS.png")],
}
dot_candidates = {
    "Leiden":  [
        os.path.join(FIG_DIR, "dotplot_roc_panel_LEIDEN.png")
    ],
    "Louvain": [os.path.join(FIG_DIR, "dotplot_roc_panel_LOUVAIN.png")],
    "KMeans":  [os.path.join(FIG_DIR, "dotplot_roc_panel_KMEANS.png")],
}

def first_existing(paths):
    for p in paths:
        if os.path.exists(p):
            return p
    return None

umap_files = [(m, first_existing(p)) for m, p in umap_candidates.items() if first_existing(p)]
dot_files  = [(m, first_existing(p)) for m, p in dot_candidates.items() if first_existing(p)]

# horizontal 1×N panel
def make_panel_horizontal(pairs, out_path, suptitle):
    if not pairs:
        print(f"no images found for {suptitle}")
        return
    n = len(pairs)
    fig, axes = plt.subplots(1, n, figsize=(5*n, 5))
    if n == 1:
        axes = [axes]
    for ax, (method, path) in zip(axes, pairs):
        img = mpimg.imread(path)
        ax.imshow(img)
        ax.set_title(method, fontsize=18, pad=10)
        ax.axis("off")
    fig.suptitle(suptitle, fontsize=20, y=0.98)
    plt.tight_layout(rect=(0, 0, 1, 0.95))
    fig.savefig(out_path, dpi=150)
    plt.show()
    print("Saved:", out_path)

# vertical panel
def make_panel_vertical(pairs, out_path, suptitle):
    """Create a vertical stack of images with minimal spacing between them."""
    if not pairs:
        print(f"no images found for {suptitle}")
        return
    n = len(pairs)
    fig, axes = plt.subplots(n, 1, figsize=(12, 4*n))
    if n == 1:
        axes = [axes]

    for ax, (method, path) in zip(axes, pairs):
        img = mpimg.imread(path)
        ax.imshow(img)
        ax.set_title(method, fontsize=14, pad=2)
        ax.axis("off")

    # tight layout and smaller spacing
    plt.subplots_adjust(hspace=0.02, top=0.96, bottom=0.02)
    fig.suptitle(suptitle, fontsize=14, y=0.995)

    fig.savefig(out_path, dpi=200, bbox_inches="tight", pad_inches=0.1)
    plt.show()
    print("Saved:", out_path)

combined_umap_path = os.path.join(FIG_DIR, "combined_umaps_roc.png")
make_panel_horizontal(
    umap_files,
    combined_umap_path,
    "UMAP highlighting ROC cluster (Leiden / Louvain / KMeans)"
)

combined_dot_path  = os.path.join(FIG_DIR, "combined_dotplots_vertical_roc.png")
make_panel_vertical(
    dot_files,
    combined_dot_path,
    "Expression of ROC reference genes across clusters (Leiden / Louvain / KMeans)")

print("\n=== Leiden Cluster Markers ===")
pd.set_option("display.max_columns", None)
display(pd.DataFrame(adata.uns["wilcox"]["names"]).head(5))

print("\n=== Louvain Cluster Markers ===")
pd.set_option("display.max_columns", None)
display(pd.DataFrame(adata.uns["louvain_wilcox"]["names"]).head(5))

print("\n=== KMeans Cluster Markers ===")
pd.set_option("display.max_columns", None)
display(pd.DataFrame(adata.uns["kmeans_logreg"]["names"]).head(5))

# only label the skin-related clusters
leiden_labels = {
    "18": "ROC"}

louvain_labels = {
    "7": "ROC"}

kmeans_labels = {
    "5": "ROC"}

# use original clustering columns
adata.obs["plot_leiden_named"] = adata.obs["leiden"].map(leiden_labels).fillna(adata.obs["leiden"])
adata.obs["plot_louvain_named"] = adata.obs["louvain"].map(louvain_labels).fillna(adata.obs["louvain"])
adata.obs["plot_kmeans_named"] = adata.obs["kmeans"].map(kmeans_labels).fillna(adata.obs["kmeans"])

import matplotlib.pyplot as plt, matplotlib.colors as mcolors
import seaborn as sns
import os

pal = [*plt.get_cmap("tab20").colors,
       *plt.get_cmap("tab20b").colors,
       *plt.get_cmap("tab20c").colors]
base_hex = [mcolors.to_hex(c) for c in pal]

def lighten_hex(hex_color, amount=0.6):
    r, g, b = mcolors.to_rgb(hex_color)
    r = r + (1.0 - r) * amount
    g = g + (1.0 - g) * amount
    b = b + (1.0 - b) * amount
    return mcolors.to_hex((r, g, b))

#make a light/pastel version of the palette
distinct_palette = [lighten_hex(h, amount=0.55) for h in base_hex]

fig, axes = plt.subplots(1, 3, figsize=(16, 5))

# leiden umap
sc.pl.umap(
    adata,
    color="plot_leiden_named",
    title="Leiden — ROC cluster named",
    legend_loc="on data",
    legend_fontsize=9,
    palette=distinct_palette,
    ax=axes[0],
    frameon=False,
    show=False
)

# louvain umap
sc.pl.umap(
    adata,
    color="plot_louvain_named",
    title="Louvain — ROC cluster named",
    legend_loc="on data",
    legend_fontsize=9,
    palette=distinct_palette,
    ax=axes[1],
    frameon=False,
    show=False
)

# kmeans umap
sc.pl.umap(
    adata,
    color="plot_kmeans_named",
    title="KMeans — ROC cluster named",
    legend_loc="on data",
    legend_fontsize=9,
    palette=distinct_palette,
    ax=axes[2],
    frameon=False,
    show=False
)

fig.suptitle("UMAPs of skin clusters with ROC highlighted (Leiden / Louvain / K-Means)", fontsize=14, y=0.98)
plt.subplots_adjust(top=0.90)  # leave space for the suptitle

plt.tight_layout()
plt.savefig(os.path.join(FIG_DIR, "umap_named_skin_clusters_roc_clusters_distinct.png"), dpi=150)
plt.show()

import os, numpy as np, pandas as pd, scanpy as sc

BASE_DIR = globals().get("BASE_DIR", "/content/drive/MyDrive/DataScienceMiniProject1")
OUT_DIR  = globals().get("OUT_DIR",  f"{BASE_DIR}/outputs")
REFS_DIR = globals().get("REFS_DIR", f"{BASE_DIR}/refs")
os.makedirs(OUT_DIR, exist_ok=True)
os.makedirs(REFS_DIR, exist_ok=True)

def clean_sym(x: str) -> str:
    s = str(x).upper().strip()
    s = s.split(".")[0].split("_")[0]
    return s

def clean_list(lst):
    return [clean_sym(x) for x in lst]


roc_csv = os.path.join(REFS_DIR, "rocGenes.csv")
if not os.path.exists(roc_csv):
    raise FileNotFoundError(f"Missing ROC reference file: {roc_csv}")
roc_ref = pd.read_csv(roc_csv, header=None).iloc[:,0].astype(str).map(clean_sym).tolist()
roc_ref_set = set(roc_ref)

#ensure a raw layer
if adata.raw is None:
    ad_norm = adata.copy()
    sc.pp.normalize_total(ad_norm, target_sum=1e4)
    sc.pp.log1p(ad_norm)
    adata.raw = ad_norm

#compute Leiden DE (Wilcoxon) if needed
if "wilcox" not in adata.uns:
    sc.tl.rank_genes_groups(adata, groupby="leiden", method="wilcoxon",
                            use_raw=True, key_added="wilcox")

# recompute roc_cluster from Leiden to avoid tale globals
wilcox_names_all = pd.DataFrame(adata.uns["wilcox"]["names"])
overlaps = {}
for cl_ in wilcox_names_all.columns:
    top50 = set(clean_list(wilcox_names_all[cl_][:50]))
    overlaps[cl_] = len(top50 & roc_ref_set)
roc_cluster_leiden = max(overlaps, key=overlaps.get)
print(f"Set roc_cluster_leiden = {roc_cluster_leiden} (overlap(top-50) = {overlaps[roc_cluster_leiden]})")

# sanity check
if adata.raw is not None and "symbol_clean" in adata.raw.var:
    present_syms = set(adata.raw.var["symbol_clean"].astype(str).map(clean_sym))
elif "symbol_clean" in adata.var:
    present_syms = set(adata.var["symbol_clean"].astype(str).map(clean_sym))
else:
    present_syms = set(pd.Index(adata.var_names).astype(str).map(clean_sym))
s3_present = len(roc_ref_set & present_syms)
print(f"S3 genes present in matrix: {s3_present}/{len(roc_ref_set)}")

# build marker table for that Leiden cluster
cl = str(roc_cluster_leiden)
U = adata.uns["wilcox"]
names  = pd.Series(U["names"][cl])
scores = pd.Series(U["scores"][cl]).astype(float)
has_lfc = "logfoldchanges" in U
lfc    = pd.Series(U["logfoldchanges"][cl]).astype(float) if has_lfc else pd.Series(np.nan, index=names.index)

df_markers = (pd.DataFrame({"gene": names, "score": scores, "logfc": lfc})
                .assign(sym=lambda d: d["gene"].map(clean_sym))
                .query("logfc > 0 or @has_lfc == False")
                .sort_values(["score", "logfc"], ascending=False, na_position="last"))

# sanity check -  S3 hits within top-50 for this cluster
cl_markers = set(clean_list(U["names"][cl][:50]))
shared = sorted(cl_markers & roc_ref_set)
print(f"ROC genes driving Leiden cluster {cl} identity (S3 overlap): {shared}")

TOPKS = [50, 100, 200]
s3_set = set(roc_ref_set)

def validate_vs_s3(df_markers, s3_set, cl, topk, out_dir):
    top = df_markers.head(topk).copy()
    shared = sorted(set(top["sym"]) & s3_set)
    precision = len(shared) / len(top) if len(top) else np.nan
    recall    = len(shared) / len(s3_set) if len(s3_set) else np.nan

    print(f"\nS3 validation for Leiden cluster {cl} — Top-{topk}")
    print("Top markers (first 15):",
          df_markers.drop_duplicates(subset="sym", keep="first").head(15)["sym"].tolist())
    print(f"Overlap with S3: {len(shared)} genes")
    print("Shared:", shared)
    print(f"Precision: {precision:.2f} | Recall: {recall:.2f}")

    top.to_csv(os.path.join(out_dir, f"markers_cluster_{cl}_top{topk}.csv"), index=False)
    pd.Series(shared, name="shared_markers").to_csv(
        os.path.join(out_dir, f"markers_cluster_{cl}_S3_overlap_top{topk}.csv"), index=False
    )
    return {"topk": topk, "overlap": len(shared), "precision": precision, "recall": recall}

summary = pd.DataFrame([validate_vs_s3(df_markers, s3_set, cl, k, OUT_DIR) for k in TOPKS])
summary_path = os.path.join(OUT_DIR, f"s3_validation_summary_cluster_{cl}.csv")
summary.to_csv(summary_path, index=False)
print("\nSaved summary:", summary_path)

# S3 validation for Louvain & KMeans
import pandas as pd, numpy as np, os, scanpy as sc

if "louvain_wilcox" not in adata.uns and "louvain" in adata.obs:
    sc.tl.rank_genes_groups(adata, groupby="louvain", method="wilcoxon", use_raw=True, key_added="louvain_wilcox")
if "kmeans_wilcox" not in adata.uns and "kmeans" in adata.obs:
    sc.tl.rank_genes_groups(adata, groupby="kmeans", method="wilcoxon", use_raw=True, key_added="kmeans_wilcox")

def _top_overlap_cluster(uns_key, K=50):
    tbl = pd.DataFrame(adata.uns[uns_key]["names"])
    best, best_k = None, -1
    for cl_ in tbl.columns:
        topK = set(clean_list(tbl[cl_][:K]))
        k = len(topK & roc_ref_set)
        if k > best_k:
            best, best_k = str(cl_), k
    return best, best_k

def _build_markers_df(uns_key, cl):
    U = adata.uns[uns_key]
    names  = pd.Series(U["names"][cl])
    scores = pd.to_numeric(pd.Series(U["scores"][cl]), errors="coerce")
    has_lfc = "logfoldchanges" in U
    lfc    = pd.to_numeric(pd.Series(U["logfoldchanges"][cl]), errors="coerce") if has_lfc else pd.Series(np.nan, index=names.index)
    df = pd.DataFrame({"gene": names, "score": scores, "logfc": lfc})
    df["sym"] = df["gene"].map(clean_sym)

    #only filter bylogFC if it exists, else keep all and rank by score
    if df["logfc"].notna().any():
        df_pos = df[df["logfc"] > 0]
        if df_pos.empty: df_pos = df
    else:
        df_pos = df
    df_pos["_lfc_sort"] = df_pos["logfc"].fillna(-np.inf)
    df_pos = df_pos.sort_values(["score", "_lfc_sort"], ascending=False).drop(columns=["_lfc_sort"])
    return df_pos

def _validate_vs_s3(df_markers, s3_set, cl, topk, out_dir, tag):
    top = df_markers.head(topk).copy()
    shared = sorted(set(top["sym"]) & s3_set)
    precision = len(shared) / len(top) if len(top) else np.nan
    recall    = len(shared) / len(s3_set) if len(s3_set) else np.nan
    print(f"[{tag}] S3 validation for cluster {cl} — Top-{topk}")
    print("Top markers (first 15):", df_markers.drop_duplicates(subset="sym").head(15)["sym"].tolist())
    print(f"Overlap with S3: {len(shared)} | Precision: {precision:.2f} | Recall: {recall:.2f}")
    top.to_csv(os.path.join(out_dir, f"markers_cluster_{cl}_{tag}_top{topk}.csv"), index=False)
    pd.Series(shared, name="shared_markers").to_csv(
        os.path.join(out_dir, f"markers_cluster_{cl}_{tag}_S3_overlap_top{topk}.csv"), index=False
    )
    return {"tag": tag, "topk": topk, "overlap": len(shared), "precision": precision, "recall": recall}

for method, uns_key in [("louvain","louvain_wilcox"), ("kmeans","kmeans_wilcox")]:
    if uns_key not in adata.uns:
        print(f"[WARN] skipping {method} — {uns_key} missing")
        continue
    cl, k = _top_overlap_cluster(uns_key, K=50)
    print(f"\nSet roc_cluster_{method} = {cl} (overlap(top-50) = {k})")
    dfm = _build_markers_df(uns_key, cl)
    rows = [_validate_vs_s3(dfm, roc_ref_set, cl, K, OUT_DIR, tag=method) for K in [50,100,200]]
    pd.DataFrame(rows).to_csv(os.path.join(OUT_DIR, f"s3_validation_summary_cluster_{cl}_{method}.csv"), index=False)

cl18_markers = set(clean_list(wilcox_names['18'][:50]))
shared = cl18_markers & roc_ref_set
print("ROC genes driving cluster 18 identity:", shared)

N_TOP = 15 # choose 15 top represented genes in order to make dotplot more compact for the writeup

#pull rank_genes_groups stats for the chosen ROC cluster
key = "wilcox"
cl  = str(roc_cluster)
rg  = adata.uns[key]


df = pd.DataFrame({
    "gene": rg["names"][cl],
    "score": rg["scores"][cl],
    "pval_adj": rg["pvals_adj"][cl]
})

if "logfoldchanges" in rg:
    df["logFC"] = rg["logfoldchanges"][cl]
else:
    df["logFC"] = np.nan

#clean symbols to compare against the Supplementary Table 3 ROC list
def _clean_sym(x: str) -> str:
    s = str(x).upper()
    s = s.split(".")[0]
    s = s.split("_")[0]
    return s
df["symbol_clean"] = df["gene"].map(_clean_sym)

#keep only genes that are in the ROC reference set
df["in_S3"] = df["symbol_clean"].isin(roc_ref_set)
roc_hits = df[df["in_S3"]].copy()

# if nothing overlaps, fall back
fallback_genes = ['EGFL6','FREM2','PLTP','NID2','IGFBP2']

#rank by effect size (logFC) if available; otherwise use Wilcoxon score
if roc_hits["logFC"].notna().any():
    roc_hits = roc_hits.sort_values(by="logFC", ascending=False)
else:
    roc_hits = roc_hits.sort_values(by="score", ascending=False)

#select top-N symbols
top_syms = roc_hits["symbol_clean"].head(N_TOP).tolist()
if len(top_syms) == 0:
    print("No overlap with S3 in this cluster's markers; using fallback ROC-like genes if present.")
    top_syms = fallback_genes

#map cleaned symbols back to actual var_names present in AnnData (raw preferred)
def map_syms_to_varnames(target_syms, var_symbols, var_names):
    target = set(target_syms); hits = []
    for i, sym in enumerate(var_symbols):
        if sym in target:
            hits.append(var_names[i])
    return hits

use_raw_flag = (adata.raw is not None) and ("symbol_clean" in getattr(adata.raw.var, "columns", []))

panel_names = []
if use_raw_flag:
    panel_names = map_syms_to_varnames(
        top_syms,
        adata.raw.var["symbol_clean"].tolist(),
        list(adata.raw.var_names)
    )
if not panel_names:  # fallback to current layer if raw mapping empty
    panel_names = map_syms_to_varnames(
        top_syms,
        adata.var["symbol_clean"].tolist(),
        list(adata.var_names)
    )
    use_raw_flag = False if panel_names else use_raw_flag  # if still empty, keep prior flag

#save the ranked list
top_table = roc_hits[roc_hits["symbol_clean"].isin(top_syms)].copy()
top_table = top_table[["gene","symbol_clean","logFC","score","pval_adj","in_S3"]]
out_csv = os.path.join(OUT_DIR, f"cluster{cl}_top{N_TOP}_ROC_genes_ranked.csv")
top_table.to_csv(out_csv, index=False)
print(f"Saved ranked top-{N_TOP} ROC genes for cluster {cl}: {out_csv}")

#make the clean dot plot
if len(panel_names) == 0:
    print("None of the selected genes are present in AnnData var/raw.var. Check symbol mapping.")
else:
    sc.pl.dotplot(
        adata,
        var_names=panel_names,
        groupby="leiden",
        standard_scale='var',
        color_map="plasma",
        dot_max=0.6,
        dendrogram=False,
        use_raw=use_raw_flag,
        title=f"Top ROC-associated genes (cluster {cl}) across clusters",
        save=f"_roc_top{N_TOP}_cluster{cl}.png"
    )
    print(f"Saved: {FIG_DIR}/dotplot_roc_top{N_TOP}_cluster{cl}.png")

#Compact ROC dotplots for ALL methods (Leiden/Louvain/KMeans) + combined panel
import os, glob, numpy as np, pandas as pd, scanpy as sc
from scipy.sparse import issparse
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

N_TOP   = 15
BASE_DIR = globals().get("BASE_DIR", "/content/drive/MyDrive/DataScienceMiniProject1")
FIG_DIR  = globals().get("FIG_DIR",  f"{BASE_DIR}/figures")
REFS_DIR = globals().get("REFS_DIR", f"{BASE_DIR}/refs")
os.makedirs(FIG_DIR, exist_ok=True)
sc.settings.figdir = FIG_DIR
sc.settings.autoshow = False

# helpers
def clean_sym(x: str) -> str:
    s = str(x).upper().strip()
    return s.split(".")[0].split("_")[0]

def map_syms_to_varnames(target_syms, var_symbols, var_names):
    target = set(target_syms); hits = []
    for i, sym in enumerate(var_symbols):
        if sym in target: hits.append(var_names[i])
    return hits

def pick_roc_cluster_by_top50(uns_key, roc_ref_set):
    names_tbl = pd.DataFrame(adata.uns[uns_key]["names"])
    best, best_k = None, -1
    for cl in names_tbl.columns:
        top50 = [clean_sym(g) for g in names_tbl[cl][:50]]
        k = len(set(top50) & roc_ref_set)
        if k > best_k:
            best, best_k = str(cl), k
    return best, best_k

def resolve_dotplot_path(fig_dir, cl, method, n_top):
    """Resolve the actual file that Scanpy saved (handles dotplot_ vs dotplot__)."""
    m = method.upper()
    candidates = [
        os.path.join(fig_dir, f"dotplot_roc_top{n_top}_cluster{cl}_{m}_clean.png"),
        os.path.join(fig_dir, f"dotplot__roc_top{n_top}_cluster{cl}_{m}_clean.png"),
        os.path.join(fig_dir, f"dotplotroc_top{n_top}_cluster{cl}_{m}_clean.png"),
    ]
    for p in candidates:
        if os.path.exists(p):
            return p
    hits = glob.glob(os.path.join(fig_dir, f"dotplot*roc_top{n_top}_cluster{cl}_{m}_clean.png"))
    return hits[0] if hits else None

def build_compact_panel_for(method, uns_key, cl, N_TOP=15):
    """Return (panel_varnames, use_raw_flag, out_png_path) after saving the dotplot PNG."""
    U  = adata.uns[uns_key]
    df = pd.DataFrame({
        "gene":      U["names"][cl],
        "score":     pd.Series(U["scores"][cl], dtype=float),
        "pval_adj":  U["pvals_adj"][cl] if "pvals_adj" in U else np.nan,
        "logFC":     pd.Series(U["logfoldchanges"][cl], dtype=float) if "logfoldchanges" in U else np.nan,
    })
    df["sym"] = df["gene"].map(clean_sym)

    #specificity filter: high in ROC cluster, low outside
    use_raw = adata.raw is not None
    X = (adata.raw.X if use_raw else adata.X)
    if issparse(X): X = X.toarray()

    mask_in  = (adata.obs[method].astype(str) == cl).values
    mask_out = ~mask_in

    gidx = {g:i for i,g in enumerate(adata.raw.var_names if use_raw else adata.var_names)}
    det_in, det_out, mu_in, mu_out = [], [], [], []
    for g in df["gene"]:
        i = gidx.get(g, None)
        if i is None:
            det_in.append(0.0); det_out.append(0.0); mu_in.append(0.0); mu_out.append(0.0)
            continue
        x_in  = X[mask_in,  i]
        x_out = X[mask_out, i]
        det_in.append(float((x_in  > 0).mean()))
        det_out.append(float((x_out > 0).mean()))
        mu_in.append(float(x_in.mean()))
        mu_out.append(float(x_out.mean()))
    df["det_in"]  = det_in
    df["det_out"] = det_out
    df["mu_in"]   = mu_in
    df["mu_out"]  = mu_out

    #keep positive logFC if available
    if df["logFC"].notna().any():
        df = df.query("logFC > 0")

    #rank by score, then logFC, then mean in-cluster
    df = df.sort_values(["score","logFC","mu_in"], ascending=False, na_position="last")

    #enforce specificity ,  expression
    df = df[(df["det_in"] >= 0.25) & (df["det_in"] >= 2*np.maximum(df["det_out"], 1e-6))]

    #unique symbols
    df = df.drop_duplicates(subset="sym", keep="first").reset_index(drop=True)

    #select top-N symbols
    top_syms = df["sym"].head(N_TOP).tolist()
    if not top_syms:
        top_syms = (pd.DataFrame({"sym": df["sym"], "score": df["score"], "logFC": df["logFC"]})
                    .drop_duplicates("sym").sort_values(["score","logFC"], ascending=False)
                    ["sym"].head(N_TOP).tolist())

    #map symbols back to varnames
    panel = []
    use_raw_flag = False
    if use_raw:
        if "symbol_clean" not in adata.raw.var.columns:
            adata.raw.var["symbol_clean"] = [clean_sym(v) for v in adata.raw.var_names]
        panel = map_syms_to_varnames(top_syms, adata.raw.var["symbol_clean"].tolist(), list(adata.raw.var_names))
        use_raw_flag = bool(panel)

    if not panel:
        if "symbol_clean" not in adata.var.columns:
            adata.var["symbol_clean"] = [clean_sym(v) for v in adata.var_names]
        panel = map_syms_to_varnames(top_syms, adata.var["symbol_clean"].tolist(), list(adata.var_names))
        use_raw_flag = False

    if panel:
        sc.pl.dotplot(
            adata,
            var_names=panel,
            groupby=method,
            standard_scale="var",
            color_map="plasma",
            dot_max=0.6,
            dendrogram=False,
            use_raw=use_raw_flag,
            show=False,
            save=f"_roc_top{N_TOP}_cluster{cl}_{method.upper()}_clean.png",
        )
        out_png = resolve_dotplot_path(FIG_DIR, cl, method, N_TOP)
        print("Saved:", out_png if out_png else "[WARN] could not resolve saved dotplot path")
        return panel, use_raw_flag, out_png
    else:
        print(f"[{method}] No selected genes mapped to var names.")
        return [], False, None

#S3 reference table
roc_csv = os.path.join(REFS_DIR, "rocGenes.csv")
if not os.path.exists(roc_csv):
    raise FileNotFoundError(f"Missing ROC reference file: {roc_csv}")
roc_ref = pd.read_csv(roc_csv, header=None).iloc[:,0].astype(str).map(clean_sym).tolist()
roc_ref_set = set(roc_ref)

# ensure DE tables exist
if "wilcox" not in adata.uns and "leiden" in adata.obs:
    sc.tl.rank_genes_groups(adata, groupby="leiden",  method="wilcoxon", key_added="wilcox")
if "louvain_wilcox" not in adata.uns and "louvain" in adata.obs:
    sc.tl.rank_genes_groups(adata, groupby="louvain", method="wilcoxon", key_added="louvain_wilcox")
if "kmeans_wilcox" not in adata.uns and "kmeans" in adata.obs:
    try:
        sc.tl.rank_genes_groups(adata, groupby="kmeans", method="wilcoxon", key_added="kmeans_wilcox")
    except Exception as e:
        print("kmeans wilcoxon failed:", e)
        if "kmeans_logreg" not in adata.uns:
            sc.tl.rank_genes_groups(adata, groupby="kmeans", method="logreg", key_added="kmeans_logreg")

#pick ROC cluster by Top-50 overlap, make compact dotplot for all 3 methods
method_defs = {
    "leiden":  "wilcox",
    "louvain": "louvain_wilcox",
    "kmeans":  "kmeans_wilcox" if "kmeans_wilcox" in adata.uns else "kmeans_logreg",
}

out_images = []
for method, uns_key in method_defs.items():
    if method not in adata.obs.columns or uns_key not in adata.uns:
        print(f"[WARN] skipping {method}: labels or DE table missing")
        continue
    cl, k_hits = pick_roc_cluster_by_top50(uns_key, roc_ref_set)
    print(f"{method}: ROC-like cluster {cl} (Top-50 S3 hits = {k_hits})")
    panel, use_raw_flag, png_path = build_compact_panel_for(method, uns_key, cl, N_TOP=N_TOP)
    if png_path is not None:
        out_images.append((method.capitalize(), png_path))

#combine the three compact dotplots into one vertical panel (tight spacing)
def make_panel_vertical(pairs, out_path, suptitle):
    if not pairs:
        print("No images found for", suptitle); return
    n = len(pairs)
    fig, axes = plt.subplots(n, 1, figsize=(12, 4*n))
    if n == 1: axes = [axes]
    for ax, (title, path) in zip(axes, pairs):
        img = mpimg.imread(path)
        ax.imshow(img)
        ax.set_title(title, fontsize=14, pad=2)
        ax.axis("off")
    plt.subplots_adjust(hspace=0.02, top=0.96, bottom=0.02)
    fig.suptitle(suptitle, fontsize=14, y=0.995)
    fig.savefig(out_path, dpi=200, bbox_inches="tight", pad_inches=0.1)
    plt.show()
    print("Saved:", out_path)

combined_dot_path = os.path.join(FIG_DIR, f"combined_compact_dotplots_vertical_roc_top{N_TOP}.png")
make_panel_vertical(
    out_images,
    combined_dot_path,
    f"Compact ROC marker dotplots (Top-{N_TOP}) — Leiden / Louvain / KMeans"
)

#Good title size

import os, glob, re, math
from PIL import Image, ImageDraw, ImageFont
from IPython.display import Image as IPyImage, display
from matplotlib import font_manager

N_TOP    = globals().get("N_TOP", 15)
BASE_DIR = globals().get("BASE_DIR", "/content/drive/MyDrive/DataScienceMiniProject1")
FIG_DIR  = globals().get("FIG_DIR",  f"{BASE_DIR}/figures")
os.makedirs(FIG_DIR, exist_ok=True)

BAND_ALPHA        = 240
SIDE_PAD_PX       = 20
TARGET_FRACTION   = 0.88
MIN_FONT_PX       = 20
MAX_FONT_FRAC_W   = 0.10
BAND_PAD_FACTOR   = 0.40

def _latest_match(patterns):
    hits = []
    for pat in patterns:
        hits.extend(glob.glob(pat))
    if not hits:
        return None
    hits.sort(key=os.path.getmtime, reverse=True)
    return hits[0]

def _resolve_font_path():
    """Find a real TTF so Pillow can scale the font size."""
    #try common families of fonts in order
    for fam in ["DejaVu Sans", "Arial", "Liberation Sans", "Noto Sans"]:
        try:
            p = font_manager.findfont(fam, fallback_to_default=False)
            if p and os.path.exists(p):
                return p
        except Exception:
            pass
    candidates = [
        "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
        "/usr/share/fonts/truetype/noto/NotoSans-Regular.ttf",
    ]
    for p in candidates:
        if os.path.exists(p):
            return p
    return None

def _text_size(draw, text, font):
    bbox = draw.textbbox((0,0), text, font=font)
    return bbox[2]-bbox[0], bbox[3]-bbox[1]

def _autofit_font(draw, title, img_w, font_path):
    """Binary search font size so text width ~ TARGET_FRACTION of image width."""
    max_w = int(img_w * TARGET_FRACTION) - 2*SIDE_PAD_PX

    # Search range
    hi = max(MIN_FONT_PX+1, int(img_w * MAX_FONT_FRAC_W))
    lo = MIN_FONT_PX
    best_font, best_w = None, 0
    while lo <= hi:
        mid = (lo + hi) // 2
        f = ImageFont.truetype(font_path, size=mid)
        w, _ = _text_size(draw, title, f)
        if w <= max_w:
            best_font, best_w = f, w
            lo = mid + 1
        else:
            hi = mid - 1
    #if nothing fit clamp to min size
    if best_font is None:
        best_font = ImageFont.truetype(font_path, size=MIN_FONT_PX)
        best_w, _  = _text_size(draw, title, best_font)
    return best_font

# 3 dotplots
pairs = []
p_leiden  = _latest_match([os.path.join(FIG_DIR, f"dotplot*roc_top{N_TOP}_cluster*_LEIDEN_clean.png")])
p_louvain = _latest_match([os.path.join(FIG_DIR, f"dotplot*roc_top{N_TOP}_cluster*_LOUVAIN_clean.png")])
p_kmeans  = _latest_match([os.path.join(FIG_DIR, f"dotplot*roc_top{N_TOP}_cluster*_KMEANS_clean.png")])
if p_leiden:  pairs.append(("Leiden",  p_leiden))
if p_louvain: pairs.append(("Louvain", p_louvain))
if p_kmeans:  pairs.append(("KMeans",  p_kmeans))

if not pairs:
    print("no compact dotplot PNGs found — run the generation cell first")
else:
    font_path = _resolve_font_path()
    if not font_path:
        print("[WARN] No TTF font found; titles may look small with default bitmap font.")
    else:
        print("[INFO] Using font:", font_path)

    for label, path in pairs:
        # parse cluster id for title
        m = re.search(r"cluster(\d+)_([A-Z]+)_clean\.png", os.path.basename(path))
        cl_txt = f"cluster {m.group(1)}" if m else ""
        title  = f"{label}: Top {N_TOP} specific markers".strip(" — ")

        #load original image
        im = Image.open(path).convert("RGBA")
        w, h = im.size

        #prepare band and font
        band = Image.new("RGBA", (w, 1), (255,255,255,BAND_ALPHA))  # temp height=1; we'll resize after text sizing
        draw = ImageDraw.Draw(band)

        if font_path:
            font = _autofit_font(draw, title, w, font_path)
        else:
            font = ImageFont.load_default()

        #measure final text size
        text_w, text_h = _text_size(draw, title, font)
        band_h = max(BAND_MIN_PX, int(text_h * (1.0 + BAND_PAD_FACTOR)))
        band   = Image.new("RGBA", (w, band_h), (255,255,255,BAND_ALPHA))
        draw   = ImageDraw.Draw(band)

        #center in band
        x = (w - text_w) // 2
        y = (band_h - text_h) // 2
        draw.text((x, y), title, fill=(0,0,0,255), font=font)

        # stack band + original image
        out = Image.new("RGBA", (w, band_h + h), (255,255,255,0))
        out.paste(band, (0,0))
        out.paste(im, (0,band_h))

        base = os.path.splitext(os.path.basename(path))[0]
        out_path = os.path.join(FIG_DIR, f"{base}_titled.png")
        out.convert("RGB").save(out_path, dpi=(200,200))
        print("Saved:", out_path)
        display(IPyImage(filename=out_path))

# look for any genes containing those ROC-like names (case-insensitive) - check how it finds them
# this is to ensure that all genes are found regarldess of case differences, weird encoding, etc
roc_like = ['EGFL6', 'FREM2', 'PLTP', 'NID2', 'IGFBP2']

for gene in roc_like:
    matches = [g for g in adata.var_names if gene.lower() in g.lower()]
    if adata.raw is not None:
        matches_raw = [g for g in adata.raw.var_names if gene.lower() in g.lower()]
    else:
        matches_raw = []
    print(f"{gene}: var={matches[:5]}  raw={matches_raw[:5]}")

# UMAP bits via symbol_clean
import numpy as np
import scipy.sparse as sp
import scanpy as sc
import os

# paths
BASE_DIR = globals().get("BASE_DIR", "/content/drive/MyDrive/DataScienceMiniProject1")
FIG_DIR  = f"{BASE_DIR}/figures"
os.makedirs(FIG_DIR, exist_ok=True)

sc.settings.autoshow = False

def _clean_sym(x: str) -> str:
    s = str(x).upper()
    return s.split(".")[0].split("_")[0]

use_raw  = adata.raw is not None
var_names = (adata.raw.var_names if use_raw else adata.var_names)
var_df    = (adata.raw.var      if use_raw else adata.var)
if "symbol_clean" not in var_df.columns:
    var_df["symbol_clean"] = [_clean_sym(g) for g in var_names]

#pick ROC cluster mask (Leiden)
cl = str(globals().get("roc_cluster_leiden", globals().get("roc_cluster", "18")))
mask_cl = (adata.obs["leiden"].astype(str) == cl).values

def pick_best_isoforms(symbols):
    """for each symbol: pick the var_name (isoform) with the highest mean inside the ROC mask"""
    picked = []
    for sym in symbols:
        idx = np.where(var_df["symbol_clean"].values == sym.upper())[0]
        if idx.size == 0:
            continue
        cand = var_names[idx]
        X = (adata.raw[:, cand].X if use_raw else adata[:, cand].X)
        X_cl = X[mask_cl, :]
        X_cl = X_cl.toarray() if sp.issparse(X_cl) else X_cl
        means = X_cl.mean(axis=0)
        picked.append(cand[int(np.argmax(means))])
    return picked

#gene-set score
roc_syms = [s.upper() for s in roc_ref]
roc_gene_list_var = pick_best_isoforms(roc_syms)
if roc_gene_list_var:
    sc.tl.score_genes(adata, gene_list=roc_gene_list_var, score_name="roc_score", use_raw=use_raw)
    sc.pl.umap(adata, color=["roc_score"], cmap="plasma", frameon=False, show=False)
else:
    print("Leiden: none of the S3 ROC genes mapped cleanly (symbol_clean).")

#single-gene feature layers
roc_like_syms = ['EGFL6','FREM2','PLTP','NID2','IGFBP2']
roc_like_var  = pick_best_isoforms(roc_like_syms)
if roc_like_var:
    sc.pl.umap(
        adata,
        color=roc_like_var,
        cmap="plasma",
        use_raw=use_raw,
        ncols=3,
        title=[f"{sym} ({vn})" for sym, vn in zip(roc_like_syms, roc_like_var)],
        frameon=False,
        show=False
    )
else:
    print("Leiden: no ROC-like genes mapped (symbol_clean).")

#leiden
roc_means_leiden = adata.obs.groupby("leiden")["roc_score"].mean().sort_values(ascending=False)
print(roc_means.head(8))  # should start with '18'
roc_means.to_csv(os.path.join(OUT_DIR, "roc_gene_score_by_cluster.csv"))

#louvain
roc_means_louvain = (adata.obs.groupby("louvain", observed=True)["roc_score"]
                     .mean().sort_values(ascending=False))
print("louvain")
print(roc_means_louvain.head(8))
roc_means_louvain.to_csv(os.path.join(OUT_DIR, "roc_gene_score_by_cluster_louvain.csv"))

#kMEans
roc_means_kmeans = (adata.obs.groupby("kmeans", observed=True)["roc_score"]
                    .mean().sort_values(ascending=False))
print("\nkmeans")
print(roc_means_kmeans.head(8))
roc_means_kmeans.to_csv(os.path.join(OUT_DIR, "roc_gene_score_by_cluster_kmeans.csv"))

import numpy as np
import matplotlib.pyplot as plt
import scipy.sparse as sp
import os

genes = ['egfl6.S','frem2.1.L','pltp.S','nid2.L','igfbp2.S']

# common max value over all panels
X = adata.raw[:, genes].X if adata.raw is not None else adata[:, genes].X
Xd = X.toarray() if sp.issparse(X) else X
vmax = float(np.quantile(Xd, 0.99))

panel_titles = [g.upper() for g in genes]

sc.pl.umap(
    adata,
    color=genes,
    use_raw=True,
    cmap="plasma",
    ncols=3,
    vmin=0, vmax=vmax,
    frameon=False,
    title=panel_titles,
    show=False
)

#figure-level title
fig = plt.gcf()
plt.subplots_adjust(top=0.90)  # leave room for the suptitle
cl = str(globals().get("roc_cluster_leiden", globals().get("roc_cluster", "18")))
fig.suptitle(f"ROC-like genes concentration (upper limit={vmax:.2f})", fontsize=18)

#save figures
out_path = os.path.join(FIG_DIR, "umap_cluster18_featureplots_matchedscale.png")
fig.savefig(out_path, dpi=150, bbox_inches="tight")
plt.close(fig)

display(Image(filename=out_path))

print("note: figure results not clustering method dependant")
#note: figure results not clustering method dependant

# data Denoising (MAGIC + scVI) + recluster + metrics (Leiden + Louvain + KMeans)
import os
import numpy as np
import pandas as pd
import scanpy as sc
from sklearn.metrics import silhouette_score, adjusted_rand_score, normalized_mutual_info_score
from sklearn.cluster import KMeans

BASE_DIR = "/content/drive/MyDrive/DataScienceMiniProject1"
OUT_DIR  = f"{BASE_DIR}/outputs"
FIG_DIR  = f"{BASE_DIR}/figures"
os.makedirs(OUT_DIR, exist_ok=True)
os.makedirs(FIG_DIR, exist_ok=True)

REF_KEY = "cluster"
def silhouette_latent(a, rep_key, label_key):
    return silhouette_score(a.obsm[rep_key], a.obs[label_key].astype(str))

def ari_nmi_vs_ref(a, label_key, ref_key=REF_KEY):
    if ref_key in a.obs.columns:
        y_true = a.obs[ref_key].astype(str).values
        y_pred = a.obs[label_key].astype(str).values
        return (adjusted_rand_score(y_true, y_pred),
                normalized_mutual_info_score(y_true, y_pred))
    return (np.nan, np.nan)

metrics_frames = []


baseline_path = os.path.join(OUT_DIR, "metrics_baseline.csv")
if os.path.exists(baseline_path):
    metrics_frames.append(pd.read_csv(baseline_path))

# MAGIC
ad_magic = None
try:
    import magic
    print("Running MAGIC denoising ...")
    ad_magic = adata.copy()
    ad_magic.X = magic.MAGIC().fit_transform(ad_magic.X)

    # scale, PCA, graph/UMAP, Leiden/Louvain
    sc.pp.scale(ad_magic, max_value=10)
    sc.tl.pca(ad_magic)
    sc.pp.neighbors(ad_magic)
    sc.tl.umap(ad_magic)
    sc.tl.leiden(ad_magic, key_added="leiden", resolution=1.0)
    sc.tl.louvain(ad_magic, key_added="louvain", resolution=1.0)

    # KMeans on PCA
    km = KMeans(n_clusters=10, random_state=42, n_init="auto")
    ad_magic.obs["kmeans"] = km.fit_predict(ad_magic.obsm["X_pca"]).astype(str)

    #metrics
    sil_magic_ld = silhouette_latent(ad_magic, "X_pca", "leiden")
    ari_magic_ld, nmi_magic_ld = ari_nmi_vs_ref(ad_magic, "leiden", REF_KEY)

    sil_magic_lv = silhouette_latent(ad_magic, "X_pca", "louvain")
    ari_magic_lv, nmi_magic_lv = ari_nmi_vs_ref(ad_magic, "louvain", REF_KEY)

    sil_magic_km = silhouette_latent(ad_magic, "X_pca", "kmeans")
    ari_magic_km, nmi_magic_km = ari_nmi_vs_ref(ad_magic, "kmeans", REF_KEY)

    m_magic = pd.DataFrame([{
        "variant": "denoise_MAGIC",
        "sil_leiden":  sil_magic_ld, "ari_leiden":  ari_magic_ld, "nmi_leiden":  nmi_magic_ld,
        "sil_louvain": sil_magic_lv, "ari_louvain": ari_magic_lv, "nmi_louvain": nmi_magic_lv,
        "sil_kmeans":  sil_magic_km, "ari_kmeans":  ari_magic_km, "nmi_kmeans":  nmi_magic_km,
    }])
    m_magic.to_csv(os.path.join(OUT_DIR, "metrics_MAGIC.csv"), index=False)
    metrics_frames.append(m_magic)
    print(m_magic)

    #Leiden / Louvain / KMeans side-by-side (for my understanding)
    sc.settings.figdir = FIG_DIR
    sc.pl.umap(ad_magic, color=["leiden","louvain","kmeans"], wspace=0.4,
               title=["MAGIC Leiden","MAGIC Louvain","MAGIC KMeans"], show=False,
               save="_MAGIC_leiden_louvain_kmeans.png")

except Exception as e:
    print("MAGIC failed:", e)

#scVI
ad_scvi = None
try:
    import scvi
    print("Running scVI denoising ...")
    ad_scvi = adata.copy()

    #counts if present; otherwise raw layer
    if "counts" in ad_scvi.layers:
        scvi.model.SCVI.setup_anndata(ad_scvi, layer="counts")
    else:
        scvi.model.SCVI.setup_anndata(ad_scvi, layer=None)

    model = scvi.model.SCVI(ad_scvi, n_latent=30, gene_likelihood="nb")
    model.train(max_epochs=100, plan_kwargs={"lr": 1e-3})

    #latent graph + UMAP + Leiden/Louvain
    ad_scvi.obsm["X_scVI"] = model.get_latent_representation()
    sc.pp.neighbors(ad_scvi, use_rep="X_scVI")
    sc.tl.umap(ad_scvi)
    sc.tl.leiden(ad_scvi, key_added="leiden", resolution=1.0)
    sc.tl.louvain(ad_scvi, key_added="louvain", resolution=1.0)

    #KMeans on scVI latent
    km = KMeans(n_clusters=10, random_state=42, n_init="auto")
    ad_scvi.obs["kmeans"] = km.fit_predict(ad_scvi.obsm["X_scVI"]).astype(str)

    #metrics in scVI space
    sil_scvi_ld = silhouette_latent(ad_scvi, "X_scVI", "leiden")
    ari_scvi_ld, nmi_scvi_ld = ari_nmi_vs_ref(ad_scvi, "leiden", REF_KEY)

    sil_scvi_lv = silhouette_latent(ad_scvi, "X_scVI", "louvain")
    ari_scvi_lv, nmi_scvi_lv = ari_nmi_vs_ref(ad_scvi, "louvain", REF_KEY)

    sil_scvi_km = silhouette_latent(ad_scvi, "X_scVI", "kmeans")
    ari_scvi_km, nmi_scvi_km = ari_nmi_vs_ref(ad_scvi, "kmeans", REF_KEY)

    m_scvi = pd.DataFrame([{
        "variant": "denoise_scVI",
        "sil_leiden":  sil_scvi_ld, "ari_leiden":  ari_scvi_ld, "nmi_leiden":  nmi_scvi_ld,
        "sil_louvain": sil_scvi_lv, "ari_louvain": ari_scvi_lv, "nmi_louvain": nmi_scvi_lv,
        "sil_kmeans":  sil_scvi_km, "ari_kmeans":  ari_scvi_km, "nmi_kmeans":  nmi_scvi_km,
    }])
    m_scvi.to_csv(os.path.join(OUT_DIR, "metrics_scVI.csv"), index=False)
    metrics_frames.append(m_scvi)
    print(m_scvi)

    #picture graph for understanding
    sc.settings.figdir = FIG_DIR
    sc.pl.umap(ad_scvi, color=["leiden","louvain","kmeans"], wspace=0.4,
               title=["scVI Leiden","scVI Louvain","scVI KMeans"], show=False,
               save="_scVI_leiden_louvain_kmeans.png")

except Exception as e:
    print("scVI failed:", e)

#Baseline KMeans on original adata
try:
    from sklearn.cluster import KMeans

    ad_base = adata.copy()
    #ensure PCA exists
    if "X_pca" not in ad_base.obsm:
        sc.tl.pca(ad_base, svd_solver="arpack")

    km = KMeans(n_clusters=10, random_state=42, n_init="auto")
    ad_base.obs["kmeans"] = km.fit_predict(ad_base.obsm["X_pca"]).astype(str)

    sil_base_km = silhouette_latent(ad_base, "X_pca", "kmeans")
    ari_base_km, nmi_base_km = ari_nmi_vs_ref(ad_base, "kmeans", REF_KEY)

    #update an existing baseline row if present; else create one
    if metrics_frames:
        found = False
        for i, df in enumerate(metrics_frames):
            if "variant" in df.columns and (df["variant"] == "baseline").any():
                df.loc[df["variant"] == "baseline", ["sil_kmeans","ari_kmeans","nmi_kmeans"]] = [
                    sil_base_km, ari_base_km, nmi_base_km
                ]
                metrics_frames[i] = df
                found = True
        if not found:
            m_base_km = pd.DataFrame([{
                "variant":"baseline",
                "sil_leiden": np.nan, "ari_leiden": np.nan, "nmi_leiden": np.nan,
                "sil_louvain": np.nan, "ari_louvain": np.nan, "nmi_louvain": np.nan,
                "sil_kmeans": sil_base_km, "ari_kmeans": ari_base_km, "nmi_kmeans": nmi_base_km,
            }])
            metrics_frames.append(m_base_km)
    else:
        m_base_km = pd.DataFrame([{
            "variant":"baseline",
            "sil_leiden": np.nan, "ari_leiden": np.nan, "nmi_leiden": np.nan,
            "sil_louvain": np.nan, "ari_louvain": np.nan, "nmi_louvain": np.nan,
            "sil_kmeans": sil_base_km, "ari_kmeans": ari_base_km, "nmi_kmeans": nmi_base_km,
        }])
        metrics_frames.append(m_base_km)

except Exception as e:
    print("Baseline KMeans metrics failed:", e)

#combine metrics
if metrics_frames:
    denoise_cmp = pd.concat(metrics_frames, ignore_index=True)
    denoise_cmp.to_csv(os.path.join(OUT_DIR, "metrics_denoising_all.csv"), index=False)
    print("\n=== Denoising comparison summary ===")
    print(denoise_cmp)
else:
    print("No denoising metrics to summarize (both methods failed to run).")

#Harmony + BBKNN for ALL 3 methods (Leiden/Louvain/KMeans)
import os, numpy as np, pandas as pd, scanpy as sc
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score, adjusted_rand_score, normalized_mutual_info_score


BASE_DIR = globals().get("BASE_DIR", "/content/drive/MyDrive/DataScienceMiniProject1")
OUT_DIR  = globals().get("OUT_DIR",  f"{BASE_DIR}/outputs")
os.makedirs(OUT_DIR, exist_ok=True)

BATCH_KEY = globals().get("BATCH_KEY", "batch")
REF_KEY   = globals().get("REF_KEY",   "cluster") # optional “truth” labels; if missing → ARI/NMI = NaN


import random
np.random.seed(42); random.seed(42)

def _sil(a, rep_key, label_key):
    return silhouette_score(a.obsm[rep_key], a.obs[label_key].astype(str))

def _ari_nmi(a, label_key, ref_key=REF_KEY):
    if ref_key in a.obs.columns:
        yt = a.obs[ref_key].astype(str).values
        yp = a.obs[label_key].astype(str).values
        return adjusted_rand_score(yt, yp), normalized_mutual_info_score(yt, yp)
    return (np.nan, np.nan)

metrics_rows = []

#HARMONY
try:
    from harmonypy import run_harmony
    if BATCH_KEY not in adata.obs.columns:
        raise KeyError(f"'{BATCH_KEY}' not found in adata.obs (set BATCH_KEY or add the column).")

    ad_hm = adata.copy()
    if "X_pca" not in ad_hm.obsm:
        sc.tl.pca(ad_hm, svd_solver="arpack")


    ad_hm.obs[BATCH_KEY] = ad_hm.obs[BATCH_KEY].astype(str).astype("category")


    meta = ad_hm.obs[[BATCH_KEY]].copy()
    Zcorr = run_harmony(ad_hm.obsm["X_pca"], meta, BATCH_KEY).Z_corr.T
    ad_hm.obsm["X_harmony"] = Zcorr

    sc.pp.neighbors(ad_hm, use_rep="X_harmony")
    sc.tl.leiden(ad_hm,  key_added="leiden",  resolution=1.0)
    sc.tl.louvain(ad_hm, key_added="louvain", resolution=1.0)

    km = KMeans(n_clusters=10, random_state=42, n_init="auto")
    ad_hm.obs["kmeans"] = km.fit_predict(ad_hm.obsm["X_harmony"]).astype(str)

    # metrics
    sil_ld = _sil(ad_hm, "X_harmony", "leiden")
    ari_ld, nmi_ld = _ari_nmi(ad_hm, "leiden", REF_KEY)

    sil_lv = _sil(ad_hm, "X_harmony", "louvain")
    ari_lv, nmi_lv = _ari_nmi(ad_hm, "louvain", REF_KEY)

    sil_km = _sil(ad_hm, "X_harmony", "kmeans")
    ari_km, nmi_km = _ari_nmi(ad_hm, "kmeans", REF_KEY)

    metrics_rows.append({
        "variant": "integrate_Harmony",
        "sil_leiden": sil_ld, "ari_leiden": ari_ld, "nmi_leiden": nmi_ld,
        "sil_louvain": sil_lv, "ari_louvain": ari_lv, "nmi_louvain": nmi_lv,
        "sil_kmeans": sil_km, "ari_kmeans": ari_km, "nmi_kmeans": nmi_km,
    })

except Exception as e:
    print("Harmony block skipped:", e)

#BBKNN
try:
    import bbknn
    if BATCH_KEY not in adata.obs.columns:
        raise KeyError(f"'{BATCH_KEY}' not found in adata.obs (set BATCH_KEY or add the column).")

    ad_bb = adata.copy()
    if "X_pca" not in ad_bb.obsm:
        sc.tl.pca(ad_bb, svd_solver="arpack")

    ad_bb.obs[BATCH_KEY] = ad_bb.obs[BATCH_KEY].astype(str).astype("category")

    bbknn.bbknn(ad_bb, batch_key=BATCH_KEY)
    sc.tl.leiden(ad_bb,  key_added="leiden",  resolution=1.0)
    sc.tl.louvain(ad_bb, key_added="louvain", resolution=1.0)

    km = KMeans(n_clusters=10, random_state=42, n_init="auto")
    ad_bb.obs["kmeans"] = km.fit_predict(ad_bb.obsm["X_pca"]).astype(str)

    #etrics
    sil_ld = _sil(ad_bb, "X_pca", "leiden")
    ari_ld, nmi_ld = _ari_nmi(ad_bb, "leiden", REF_KEY)

    sil_lv = _sil(ad_bb, "X_pca", "louvain")
    ari_lv, nmi_lv = _ari_nmi(ad_bb, "louvain", REF_KEY)

    sil_km = _sil(ad_bb, "X_pca", "kmeans")
    ari_km, nmi_km = _ari_nmi(ad_bb, "kmeans", REF_KEY)

    metrics_rows.append({
        "variant": "integrate_BBKNN",
        "sil_leiden": sil_ld, "ari_leiden": ari_ld, "nmi_leiden": nmi_ld,
        "sil_louvain": sil_lv, "ari_louvain": ari_lv, "nmi_louvain": nmi_lv,
        "sil_kmeans": sil_km, "ari_kmeans": ari_km, "nmi_kmeans": nmi_km,
    })

except Exception as e:
    print("BBKNN block skipped:", e)

#results
if metrics_rows:
    df = pd.DataFrame(metrics_rows)
    out_csv = os.path.join(OUT_DIR, "metrics_integration_all.csv")
    df.to_csv(out_csv, index=False)
    print("\n=== Integration metrics (numbers only) ===")
    print(df)
    print("\nSaved:", out_csv)
else:
    print("No integration metrics computed.")

import os
import numpy as np
import scanpy as sc
from scipy.sparse import issparse

#thisbecause my environment was crashing before that
import os, gc, numpy as np, scanpy as sc
from scipy.sparse import issparse

sc.settings.verbosity = 3  # more logs

BASE_DIR   = "/content/drive/MyDrive/DataScienceMiniProject1"
CLEAN_FILE = f"{BASE_DIR}/Frogtail_files/CleanedData/cleaned_processed_frogtail.h5ad"

def here(msg): print(f"\nH-SETUP >>> {msg}")
def exists(p):
    if not os.path.exists(p):
        raise FileNotFoundError(f"Missing file: {p}")
    return True

def to_csr_inplace(ad):
    if issparse(ad.X):
        ad.X = ad.X.tocsr()

def looks_log1p(sample):
    if sample.size == 0: return False
    maxv = float(np.nanmax(sample))
    frac = np.mean(np.abs(sample - np.round(sample)) > 1e-6)
    return (maxv < 20) and (frac > 0.5)

def ensure_counts(ad):
    """Create ad.layers['counts'] only if safe (no full densification)."""
    if "counts" in ad.layers:
        return
    #small sample to infer scaling
    if issparse(ad.X):
        sample = ad.X[:min(50, ad.n_obs)].toarray()
    else:
        sample = ad.X[:min(2000, ad.n_obs)]
    try:
        if looks_log1p(np.asarray(sample)):
            print("Counts layer skipped (X appears log1p).")
        else:
            ad.layers["counts"] = ad.X
    except Exception as e:
        print(f"Counts inference failed: {e}; leaving counts unset.")

def coerce_finite_X(ad):
    if issparse(ad.X):
        Xd = ad.X.toarray()
        if not np.isfinite(Xd).all():
            print("Non-finite values in X; replacing with 0.")
            Xd = np.nan_to_num(Xd, nan=0.0, posinf=0.0, neginf=0.0)
            ad.X = Xd
    else:
        if not np.isfinite(ad.X).all():
            print("Non-finite values in X; replacing with 0.")
            ad.X = np.nan_to_num(ad.X, nan=0.0, posinf=0.0, neginf=0.0)

def mem_estimate_bytes(ad):
    if issparse(ad.X):
        return int(ad.X.nnz * 16)
    else:
        return int(ad.X.size * 8)

def lighten(ad, drop_raw=True):
    if drop_raw and getattr(ad, "raw", None) is not None:
        ad.raw = None
        print("Dropped .raw to save RAM.")

# load data
try:
    if "adata" not in globals():
        here("loading adata")
        exists(CLEAN_FILE)
        adata = sc.read_h5ad(CLEAN_FILE)
    else:
        here("using in-memory adata")
except Exception as e:
    raise RuntimeError(f"Failed to load adata: {e}")

# basic sanitation
here("sanitizing X / counts")
to_csr_inplace(adata)
coerce_finite_X(adata)
ensure_counts(adata)

#reduce memory
lighten(adata, drop_raw=True)

#cast to float32 to trim memory
if issparse(adata.X):
    adata.X.data = adata.X.data.astype("float32")
else:
    adata.X = adata.X.astype("float32", copy=False)

print(f"Cells: {adata.n_obs:,}  Genes: {adata.n_vars:,}")
print(f"~Memory for X (rough): {mem_estimate_bytes(adata)/1e9:.2f} GB")

#PCA / neighbors / UMAP / Leiden
needs_pca    = "X_pca" not in adata.obsm
needs_nbr    = "neighbors" not in adata.uns
needs_umap   = "X_umap" not in adata.obsm
needs_leiden = "leiden" not in adata.obs.columns

try:
    if needs_pca:
        here("PCA")
        n_comps = int(min(50, max(2, min(adata.n_obs - 1, adata.n_vars - 1))))
        sc.tl.pca(adata, n_comps=n_comps, svd_solver="arpack")
    if needs_nbr:
        here("neighbors")
        n_pcs = int(min(50, adata.obsm["X_pca"].shape[1])) if "X_pca" in adata.obsm else 20
        n_pcs = max(2, n_pcs)
        sc.pp.neighbors(adata, n_neighbors=15, n_pcs=n_pcs)
    if needs_umap:
        here("UMAP")
        sc.tl.umap(adata)
    if needs_leiden:
        here("Leiden")
        sc.tl.leiden(adata, key_added="leiden", resolution=1.0)
except Exception as e:
    raise RuntimeError(f"Embedding/Clustering step failed: {e}")

#adata_base
here("creating ADATA_BASE (copy of adata)")
ADATA_BASE = adata.copy()
ensure_counts(ADATA_BASE)

#Trim heavy attachments on ADATA_BASE
here("shrinking ADATA_BASE attachments")
try:
    if hasattr(ADATA_BASE, "obsm"): ADATA_BASE.obsm.clear()
    if hasattr(ADATA_BASE, "varm"): ADATA_BASE.varm.clear()
except Exception:
    pass

#align indeces
here("aligning adata / ADATA_BASE")
if set(ADATA_BASE.obs_names) == set(adata.obs_names):
    ADATA_BASE = ADATA_BASE[adata.obs_names].copy()
else:
    common = ADATA_BASE.obs_names.intersection(adata.obs_names)
    print(f"Restricting to common cells: {len(common)}")
    ADATA_BASE = ADATA_BASE[common].copy()
    adata      = adata[common].copy()
    for _nm in ["ad_magic","ad_scvi","ad_hm","ad_bb"]:
        if _nm in globals() and globals()[_nm] is not None:
            globals()[_nm] = globals()[_nm][common].copy()

gc.collect()
here("DONE — H-SETUP complete")

# roc-overlap robustness with log checks
import os, numpy as np, pandas as pd, scanpy as sc
from scipy.sparse import issparse
from scipy import sparse

base_dir = "/content/drive/MyDrive/DataScienceMiniProject1"
out_dir  = f"{base_dir}/outputs"
refs_dir = f"{base_dir}/refs"
os.makedirs(out_dir, exist_ok=True)
os.makedirs(refs_dir, exist_ok=True)

#helper log1p (sanity check)
def _looks_log1p(X):
    if X is None:
        return False
    d = X.data if issparse(X) else np.asarray(X)
    if d.size == 0:
        return False
    maxv = float(np.nanmax(d))
    frac_nonint = float(np.mean(np.abs(d - np.round(d)) > 1e-6)) if d.size > 0 else 0.0
    return (maxv < 20.0) and (frac_nonint > 0.5)

#ensure csr
if not issparse(adata.X):
    adata.X = sparse.csr_matrix(adata.X)

#ensure a raw counts
if "counts" not in adata.layers:
    if _looks_log1p(adata.X):
        cnt = adata.X.copy()
        cnt.data = np.expm1(cnt.data) if issparse(cnt) else np.expm1(cnt)
        adata.layers["counts"] = cnt
        print("created counts layer from log1p x via expm1")
    else:
        adata.layers["counts"] = adata.X.copy()
        print("created counts layer by copying x (x looked like counts)")
else:
    print("counts layer already present")

#ensure main matrix x is log1p
if not _looks_log1p(adata.X):
    print("x does not look log1p → normalizing and logging x")
    sc.pp.normalize_total(adata, target_sum=1e4)
    sc.pp.log1p(adata)


if getattr(adata, "raw", None) is None:
    if "ADATA_BASE" in globals():
        print("building .raw from ADATA_BASE (full gene space)")
        ad_norm = ADATA_BASE.copy()
        if not issparse(ad_norm.X):
            ad_norm.X = sparse.csr_matrix(ad_norm.X)
        if not _looks_log1p(ad_norm.X):
            sc.pp.normalize_total(ad_norm, target_sum=1e4)
            sc.pp.log1p(ad_norm)
        adata.raw = ad_norm
    else:
        print("building .raw from current object (gene subset) using counts → log1p")
        ad_norm = adata.copy()
        Xc = adata.layers["counts"]
        if issparse(Xc):
            Xlog = Xc.copy()
            Xlog.data = np.log1p(Xlog.data)
        else:
            Xlog = np.log1p(Xc)
        ad_norm.X = Xlog
        ad_norm.uns["log1p"] = {"base": None}
        adata.raw = ad_norm

#load roc reference
roc_csv = os.path.join(refs_dir, "rocGenes.csv")
if not os.path.exists(roc_csv):
    pd.Series([
        "WNT5A","LOC100488523","LOC100492954","EGFL6","LPAR3","CPA6","SP9","FGF9","FBN2","TINAGL1",
        "FGF7","VWDE","LEF1","LAMB2","FGFR4","RSPO2","CPA6","LOC100498358","KRT","LOC100486832",
        "JAG1","XELAEV18043128M","DLX2","TP73","GDF6","XELAEV18046800M","NID2","IGFBP2","ISM2",
        "LOC100493805","FREM2","XELAEV18044182M","BMP5","TSPEAR","SEMA3F","ROBO4","JCHAIN",
        "ADAMTS18","PLTP","XELAEV18034799M","LAMB1","UNC5B","MMP28","FGF10","PZP","GALNT15"
    ]).to_csv(roc_csv, index=False, header=False)
roc_ref = pd.read_csv(roc_csv, header=None).iloc[:,0].astype(str).str.upper().tolist()
roc_ref_set = set(roc_ref)


def clean_symbol(x: str) -> str:
    s = str(x).upper()
    return s.split(".")[0].split("_")[0]

#compute max overlap for top-n markers per cluster using .raw (log1p)
def roc_overlap_max(a, topn=50, key="wilcox_robust"):
    if "leiden" not in a.obs.columns:
        sc.tl.leiden(a, key_added="leiden", resolution=1.0)
    sc.tl.rank_genes_groups(a, "leiden", method="wilcoxon", use_raw=True, key_added=key)
    names = pd.DataFrame(a.uns[key]["names"])
    best = 0
    for cl in names.columns:
        top = {clean_symbol(g) for g in names[cl][:topn]}
        best = max(best, len(top & roc_ref_set))
    return best

rob = []

#resolution sweep on baseline object
for res in [0.6, 1.0, 1.2]:
    ax = adata.copy()
    sc.tl.leiden(ax, key_added="leiden", resolution=res)
    rob.append({
        "variant": f"baseline_res{res}",
        "roc_overlap_top50":  roc_overlap_max(ax, topn=50,  key=f"wilcox_res{res}_50"),
        "roc_overlap_top100": roc_overlap_max(ax, topn=100, key=f"wilcox_res{res}_100"),
        "roc_overlap_top200": roc_overlap_max(ax, topn=200, key=f"wilcox_res{res}_200"),
    })

#80% subsample ( robustness)
rng = np.random.default_rng(42)
keep = rng.choice(adata.n_obs, size=int(0.8 * adata.n_obs), replace=False)
ad_sub = adata[keep].copy()

# ensure neighbors/umap present for the subset
if "X_pca" not in ad_sub.obsm:
    n_comps = 30 if "X_pca" not in adata.obsm else min(30, adata.obsm["X_pca"].shape[1])
    sc.tl.pca(ad_sub, n_comps=n_comps, svd_solver="arpack")
if "neighbors" not in ad_sub.uns:
    sc.pp.neighbors(ad_sub, n_neighbors=15, n_pcs=min(30, ad_sub.obsm["X_pca"].shape[1]))
if "X_umap" not in ad_sub.obsm:
    sc.tl.umap(ad_sub)
sc.tl.leiden(ad_sub, key_added="leiden", resolution=1.0)

rob.append({
    "variant": "baseline_subsample80",
    "roc_overlap_top50":  roc_overlap_max(ad_sub, topn=50,  key="wilcox_sub_50"),
    "roc_overlap_top100": roc_overlap_max(ad_sub, topn=100, key="wilcox_sub_100"),
    "roc_overlap_top200": roc_overlap_max(ad_sub, topn=200, key="wilcox_sub_200"),
})

robust_df = pd.DataFrame(rob)
robust_df.to_csv(os.path.join(out_dir, "robustness.csv"), index=False)
print("robustness of roc overlap under resolution/subsampling")
print(robust_df)